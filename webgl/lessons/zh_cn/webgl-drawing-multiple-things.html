<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-drawing-multiple-things.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 绘制多个物体" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="如何使用WebGL绘制多个物体" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-drawing-multiple-things.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 绘制多个物体" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-drawing-multiple-things.html" />
<meta name="twitter:description" content="如何使用WebGL绘制多个物体" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 绘制多个物体</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 绘制多个物体</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>此文上接<a href="webgl-fundamentals.html">一系列WebGL相关文章</a>，
如果没读请从那里开始。</p>
<p>学到WebGL的一些基础以后，面临的一个问题可能是如何绘制多个物体。</p>
<p>这里有一些特别的地方你需要提前了解，WebGL就像是一个方法，
但不同于一般的方法直接传递参数，它需要调用一些方法去设置状态，
最后用某个方法执行绘制，并使用之前设置的状态。你在写代码时可能会用这种形式的方法</p>
<pre><code>function drawCircle(centerX, centerY, radius, color) { ... }
</code></pre><p>或者用这种形式的方法</p>
<pre><code>var centerX;
var centerY;
var radius;
var color;

function setCenter(x, y) {
   centerX = x;
   centerY = y;
}

function setRadius(r) {
   radius = r;
}

function setColor(c) {
   color = c;
}

function drawCircle() {
   ...
}
</code></pre><p>WebGL使用的是后一种形式，例如 <code>gl.createBuffer</code>,
<code>gl.bufferData</code>, <code>gl.createTexture</code>, 和 <code>gl.texImage2D</code>
方法让你上传缓冲（顶点）或者纹理（颜色等）给WebGL，
<code>gl.createProgram</code>, <code>gl.createShader</code>, <code>gl.compileProgram</code>, 和
<code>gl.linkProgram</code> 让你创建自己的 GLSL 着色器，
剩下的所有方法几乎都是设置全局变量或者最终方法 <code>gl.drawArrays</code> 或 <code>gl.drawElements</code>
需要的<strong>状态</strong>。 </p>
<p>清楚这个以后，WebGL应用基本都遵循以下结构</p>
<p>初始化阶段</p>
<ul>
<li>创建所有着色器和程序并寻找参数位置</li>
<li>创建缓冲并上传顶点数据</li>
<li>创建纹理并上传纹理数据</li>
</ul>
<p>渲染阶段</p>
<ul>
<li>清空并设置视图和其他全局状态（开启深度检测，剔除等等）</li>
<li>对于想要绘制的每个物体<ul>
<li>调用 <code>gl.useProgram</code> 使用需要的程序</li>
<li>设置物体的属性变量<ul>
<li>为每个属性调用 <code>gl.bindBuffer</code>, <code>gl.vertexAttribPointer</code>, <code>gl.enableVertexAttribArray</code></li>
</ul>
</li>
<li>设置物体的全局变量<ul>
<li>为每个全局变量调用 <code>gl.uniformXXX</code></li>
<li>调用 <code>gl.activeTexture</code> 和 <code>gl.bindTexture</code> 设置纹理到纹理单元</li>
</ul>
</li>
<li>调用 <code>gl.drawArrays</code> 或 <code>gl.drawElements</code></li>
</ul>
</li>
</ul>
<p>基本上就是这些，详细情况取决于你的实际目的和代码组织情况。</p>
<p>有的事情例如上传纹理数据（甚至时顶点数据）可能遇到异步，
你就需要等所有资源下载完成后才能开始。</p>
<p>让我们来做一个简单的应用，绘制三个物体，一个立方体，一个球体，一个椎体。</p>
<p>我不会详细介绍如何计算出立方体，球体和椎体数据，
假设有方法能够返回<a href="webgl-less-code-more-fun.html">上篇文章中的 bufferInfo 对象</a>。</p>
<p>这是代码，着色器是<a href="webgl-3d-perspective.html">透视示例</a>中的简单的着色器，
新添加了一个 <code>u_colorMult</code> 全局变量和顶点颜色相乘。</p>
<pre><code>// 从顶点着色器中传入的值
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</code></pre><p>初始化阶段</p>
<pre><code>// 每个物体需要的全局变量
var sphereUniforms = {
  u_colorMult: [0.5, 1, 0.5, 1],
  u_matrix: m4.identity(),
};
var cubeUniforms = {
  u_colorMult: [1, 0.5, 0.5, 1],
  u_matrix: m4.identity(),
};
var coneUniforms = {
  u_colorMult: [0.5, 0.5, 1, 1],
  u_matrix: m4.identity(),
};

// 每个物体的平移量
var sphereTranslation = [  0, 0, 0];
var cubeTranslation   = [-40, 0, 0];
var coneTranslation   = [ 40, 0, 0];
</code></pre><p>绘制阶段</p>
<pre><code>var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;

// ------ 绘制球体 --------

gl.useProgram(programInfo.program);

// 设置所需的属性变量
webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);

sphereUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);

// 设置刚才计算出的全局变量
webglUtils.setUniforms(programInfo, sphereUniforms);

gl.drawArrays(gl.TRIANGLES, 0, sphereBufferInfo.numElements);

// ------ 绘制立方体 --------

// 设置所需的属性变量
webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);

cubeUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);

// 设置刚才计算出的全局变量
webglUtils.setUniforms(programInfo, cubeUniforms);

gl.drawArrays(gl.TRIANGLES, 0, cubeBufferInfo.numElements);

// ------ 绘制椎体 --------

// 设置所需的属性变量
webglUtils.setBuffersAndAttributes(gl, programInfo, coneBufferInfo);

coneUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);

// 设置刚才计算出的全局变量
webglUtils.setUniforms(programInfo, coneUniforms);

gl.drawArrays(gl.TRIANGLES, 0, coneBufferInfo.numElements);
</code></pre><p>这是结果</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-manual.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-manual.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>需要注意的是，由于我们只有一个程序，所以只调用了一次 <code>gl.useProgram</code>，
如果我们有不同的着色程序，则需要在使用前调用 <code>gl.useProgram</code>。</p>
<p>这还有一个值得简化的地方，将这三个相关的事情组合到一起。</p>
<ol>
<li>着色程序（和它的全局变量以及属性 info/setter）</li>
<li>想要绘制的物体的缓冲和属性变量</li>
<li>绘制物体所需程序的全局变量</li>
</ol>
<p>简单的简化后制作一个序列对象，将三个物体放在其中</p>
<pre><code>var objectsToDraw = [
  {
    programInfo: programInfo,
    bufferInfo: sphereBufferInfo,
    uniforms: sphereUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: cubeBufferInfo,
    uniforms: cubeUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: coneBufferInfo,
    uniforms: coneUniforms,
  },
];
</code></pre><p>绘制的时候仍然需要更新矩阵</p>
<pre><code>var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;

// 为每个物体计算矩阵
sphereUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);

cubeUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);

coneUniforms.u_matrix = computeMatrix(
    viewProjectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);
</code></pre><p>但是绘制代码就会变成一个简单的循环</p>
<pre><code>// ------ 绘制几何体 --------

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
  var bufferInfo = object.bufferInfo;

  gl.useProgram(programInfo.program);

  // 设置所需的属性
  webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

  // 设置全局变量
  webglUtils.setUniforms(programInfo, object.uniforms);

  // 绘制
  gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
});
</code></pre><p>理论上这就是大多数现有三维引擎的主要渲染循环。
其他地方的某些代码控制 <code>objectsToDraw</code> 列表中的对象，
基本上就是这样。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-list.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-list.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>这还有一些小优化，如果将要绘制的对象和前一个对象使用相同的程序，
则不需要调用 <code>gl.useProgram</code>。同样的，如果绘制的形状/几何体/顶点
是之前绘制过的，相同的参数就不必再设置一遍。</p>
<p>所以，简单的优化后可能像这样</p>
<pre><code>var lastUsedProgramInfo = null;
var lastUsedBufferInfo = null;

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
  var bufferInfo = object.bufferInfo;
  var bindBuffers = false;

  if (programInfo !== lastUsedProgramInfo) {
    lastUsedProgramInfo = programInfo;
    gl.useProgram(programInfo.program);

    // 更换程序后要重新绑定缓冲，因为只需要绑定程序要用的缓冲。
    // 如果两个程序使用相同的bufferInfo但是第一个只用位置数据，
    // 当我们从第一个程序切换到第二个时，有些属性就不存在。
    bindBuffers = true;
  }

  // 设置所需的属性
  if (bindBuffers || bufferInfo != lastUsedBufferInfo) {
    lastUsedBufferInfo = bufferInfo;
    webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  }

  // 设置全局变量
  webglUtils.setUniforms(programInfo, object.uniforms);

  // 绘制
  gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
});
</code></pre><p>这次我们多绘制一些物体，用包含更多物体的序列代替之前的三个物体。</p>
<pre><code>// 将图形放在数组中以便随机抽取
var shapes = [
  sphereBufferInfo,
  cubeBufferInfo,
  coneBufferInfo,
];

// 创建两个对象数组，一个用于绘制，一个用于使用
var objectsToDraw = [];
var objects = [];

// 每个物体的全局变量
var numObjects = 200;
for (var ii = 0; ii &lt; numObjects; ++ii) {
  // 选择一个形状
  var bufferInfo = shapes[rand(0, shapes.length) | 0];

  // 创建一个物体
  var object = {
    uniforms: {
      u_colorMult: [rand(0, 1), rand(0, 1), rand(0, 1), 1],
      u_matrix: m4.identity(),
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);

  // 添加到绘制数组中
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: bufferInfo,
    uniforms: object.uniforms,
  });
}
</code></pre><p>渲染时</p>
<pre><code>// 计算每个物体的矩阵
objects.forEach(function(object) {
  object.uniforms.u_matrix = computeMatrix(
      viewMatrix,
      projectionMatrix,
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});
</code></pre><p>然后在上方的循环中绘制所有物体。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-multiple-objects-list-optimized.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-multiple-objects-list-optimized.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>你也可以根据 <code>programInfo</code> 和/或 <code>bufferInfo</code> 对物体进行排序，
这样就会更大程度的利用优化代码，大多数游戏引擎都会这么做。
但这并不简单，如果你绘制的都是不透明物体那就可以直接排序，
但是一旦你要绘制半透明物体时，就必须按照一定的顺序绘制。
大多数三维引擎通过使用两个或多个对象数组解决这个问题，一个存储不透明物体，
另一个存储透明物体，不透明数组按照程序和几何体排序，透明数组按照深度排序，
可能还有其他数组存储覆盖物或者后处理效果等。</p>
<p><a href="../webgl-multiple-objects-list-optimized-sorted.html"
target="_blank">这是一个使用排序的例子</a>。在我的机器上从 ~31fps
提升到了 ~37fps，几乎是 20% 的性能提升。但是这是最差的情况和最好的情况的对比，
大多数应用考虑的非常全面，理论上除了一些非常特殊的情况以外，其他情况并不需要考虑太多。</p>
<p>需要特别注意的是着色器和图形往往一一对应，
例如一个需要法向量的着色器就不能用在没有法向量的几何体上，
同样的一个需要纹理的着色器在没有纹理时就无法正常运行。</p>
<p>这就是需要选择一个优质的三维引擎（例如<a href="http://threejs.org">Three.js</a>）的原因之一，
因为它可以帮你解决这些问题。你创建几何体时只需要告诉 three.js 你想如何渲染，
它就会在运行时为你创建你需要的着色器。几乎所有的三维引擎，从 Unity3D 到 Unreal
到 Source 到 Crytek，有些在离线时创建着色器，但是重要的是它们都会<strong>创建</strong>着色器。</p>
<p>当然，你阅读这些文章的目的是想知道底层原理，自己写所有的东西非常好并且也很有趣，
但是需要注意的是<a href="webgl-2d-vs-3d-library.html">WebGL是非常底层的</a>，
所以如果你想自己做所有的东西的话，要做的东西很多，通常包括着色器生成器，
因为不同的特性需要不同的着色器。</p>
<p>你可能注意到我并没有把 <code>computeMatrix</code> 放在循环中，
那是因为渲染理论上应该和矩阵计算分离，通常情况下矩阵计算放在接下来要讲的
<a href="webgl-scene-graph.html">场景图</a>中。</p>
<p>现在我们有了绘制多个物体的框架，就可以<a href="webgl-text-html.html">绘制一些文字了</a>。</p>

      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="http://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 绘制多个物体';
            var disqus_title = 'WebGL 绘制多个物体';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>基础概念</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
  </ul>
  <li>图像处理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
  </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
  </ul>
  <li>三维</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
  </ul>
  <li>光照</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
  </ul>
  <li>组织和重构</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
  </ul>
  <li>几何</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
  </ul>
  <li>纹理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>    
    <li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
  </ul>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 2D - Matrix Stack</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL Text - HTML</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL Text - Canvas 2D</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL Text - Using a Texture</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL Text - Using a Glyph Texture</a>
    </ul>
  </ul>
  <li>杂项</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL - Animation</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL and Alpha</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL - 2D vs 3D libraries</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



