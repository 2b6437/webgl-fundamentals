<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-image-processing-continued.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 进一步处理图像" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="怎么用WebGL叠加多种图像处理模式" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-image-processing-continued.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 进一步处理图像" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-image-processing-continued.html" />
<meta name="twitter:description" content="怎么用WebGL叠加多种图像处理模式" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 进一步处理图像</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 进一步处理图像</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>此文上接<a href="webgl-image-processing.html">WebGL 图像处理</a>，
如果还没有读过我建议你<a href="webgl-image-processing.html">从那里开始</a>。</p>
<p>图像处理的下一个问题是如何同时施加多种效果？</p>
<p>当然，你可以试着在运行时创建着色器，根据用户从交互界面选择的一些效果，
创建一个可以全部实现的着色器。尽管有人用过
<a href="http://www.youtube.com/watch?v=cQUn0Zeh-0Q">在运行时创建渲染效果</a>，
但是大部分情况下是不适合的。</p>
<p>一个更灵活的方式是使用2个或以上的纹理，然后交替渲染它们，
像乒乓球一样每次渲染一种效果，传给另一个渲染下一个效果，如下所示。</p>
<blockquote><pre>原始图像    -&gt; [模糊]     -&gt; 纹理纹理 1
纹理 1      -&gt; [锐化]     -&gt; 纹理 2
纹理 2      -&gt; [边缘检测] -&gt; 纹理 1
纹理 1      -&gt; [模糊]     -&gt; 纹理 2
纹理 2      -&gt; [平滑]     -&gt; 画布</pre></blockquote>

<p>这个操作需要使用帧缓冲来实现。在WebGL和OpenGL中，帧缓冲是一个事实上是一个糟糕的名字。
WebGL/OpenGL 中的帧缓冲只是一系列状态（一列附加物）不是任何形式的缓冲。
但是当我们给帧缓冲绑定一个纹理后，
可以将渲染结果写入那个纹理。</p>
<p>首先让我们把<a href="webgl-image-processing.html">以前创建纹理的代码</a>写到一个方法里</p>
<pre><code>  function createAndSetupTexture(gl) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // 设置材质，这样我们可以对任意大小的图像进行像素操作
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
  }

  // 创建一个纹理并写入图像
  var originalImageTexture = createAndSetupTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
</code></pre><p>现在让我们用这个方法生成两个纹理并绑定到两个帧缓冲。</p>
<pre><code>  // 创建两个纹理绑定到帧缓冲
  var textures = [];
  var framebuffers = [];
  for (var ii = 0; ii &lt; 2; ++ii) {
    var texture = createAndSetupTexture(gl);
    textures.push(texture);

    // 设置纹理大小和图像大小一致
    gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0,
        gl.RGBA, gl.UNSIGNED_BYTE, null);

    // 创建一个帧缓冲
    var fbo = gl.createFramebuffer();
    framebuffers.push(fbo);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

    // 绑定纹理到帧缓冲
    gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  }
</code></pre><p>现在让我们做一些卷积核并按使用顺序存入列表中</p>
<pre><code>  // 定义一些卷积核
  var kernels = {
    normal: [
      0, 0, 0,
      0, 1, 0,
      0, 0, 0
    ],
    gaussianBlur: [
      0.045, 0.122, 0.045,
      0.122, 0.332, 0.122,
      0.045, 0.122, 0.045
    ],
    unsharpen: [
      -1, -1, -1,
      -1,  9, -1,
      -1, -1, -1
    ],
    emboss: [
       -2, -1,  0,
       -1,  1,  1,
        0,  1,  2
    ]
  };

  // 将要使用的效果列表
  var effectsToApply = [
    &quot;gaussianBlur&quot;,
    &quot;emboss&quot;,
    &quot;gaussianBlur&quot;,
    &quot;unsharpen&quot;
  ];
</code></pre><p>最后让我们使用所有渲染效果，像乒乓一样来回渲染</p>
<pre><code>  // 从原始图像开始
  gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);

  // 在渲染效果时不翻转y轴
  gl.uniform1f(flipYLocation, 1);

  // 循环施加每一种渲染效果
  for (var ii = 0; ii &lt; effectsToApply.length; ++ii) {
    // 使用两个帧缓冲中的一个
    setFramebuffer(framebuffers[ii % 2], image.width, image.height);

    drawWithKernel(effectsToApply[ii]);

    // 下次绘制时使用刚才的渲染结果
    gl.bindTexture(gl.TEXTURE_2D, textures[ii % 2]);
  }

  // 最后将结果绘制到画布
  gl.uniform1f(flipYLocation, -1);  // 需要绕y轴翻转
  setFramebuffer(null, canvas.width, canvas.height);
  drawWithKernel(&quot;normal&quot;);

  function setFramebuffer(fbo, width, height) {
    // 设定当前使用帧缓冲
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

    // 告诉着色器分辨率是多少
    gl.uniform2f(resolutionLocation, width, height);

    // 告诉WebGL帧缓冲需要的视图大小
    gl.viewport(0, 0, width, height);
  }

  function drawWithKernel(name) {
    // 设置卷积核
    gl.uniform1fv(kernelLocation, kernels[name]);

    // 画出矩形
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
</code></pre><p>下面是一个可交互示例，用了稍微灵活一点的用户交互。勾选表示开启对应效果，
拖拽改变渲染顺序。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-image-processing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-image-processing.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>有些东西需要回顾一下。</p>
<p>调用 <code>gl.bindFramebuffer</code> 设置为 <code>null</code>是告诉WebGL
你想在画布上绘制，而不是在帧缓冲上。</p>
<p>WebGL需要从<a href="webgl-fundamentals.html">裁剪空间</a>对应到屏幕像素，
设置<code>gl.viewport</code>就是为了实现这个。因为我们的帧缓冲的大小和画布的大小不同，
所以我们需要给帧缓冲设置一个合适的视图大小让它渲染到对应的纹理上，最后再渲染到画布上。</p>
<p><a href="webgl-fundamentals.html">原例</a>中，我们在渲染时绕 y 轴翻转是因为WebGL
的 0, 0 点在左下角而不是常见二维屏幕坐标的左上角。而在帧缓冲中绘制的时候不需要翻转，
因为帧缓冲不用显示，谁上谁下无所谓，最重要的是我们计算中的 0, 0 也对应帧缓冲中的 0, 0
像素。为了解决这个问题，通过在着色器中添加一个输入来决定是否翻转。</p>
<pre><code>&lt;script id=&quot;2d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
...
uniform float u_flipY;
...

void main() {
   ...

   gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);

   ...
}
&lt;/script&gt;
</code></pre><p>然后在渲染的时候可以这样设置</p>
<pre><code>  ...

  var flipYLocation = gl.getUniformLocation(program, &quot;u_flipY&quot;);

  ...

  // 不翻转
  gl.uniform1f(flipYLocation, 1);

  ...

  // 翻转
  gl.uniform1f(flipYLocation, -1);
</code></pre><p>为了让这个例子简单化，我只用了一个GLSL实现了多种渲染效果。
如果专做图像处理可能需要多个GLSL程序，一个调节色彩,饱和度和明度，
一个调节亮度和对比度，一个做反色，一个做色彩平衡，等等。
你需要用代码更换GLSL程序，并更新程序对应的参数。我想过写一个类似的例子，
但最好留给读者自己实现，因为多个GLSL程序和参数需要良好的重构，
不然代码会一团糟，所以它是一个很好的练习机会。</p>
<p>希望这个和之前的例子让你更了解WebGL，从二维开始讲解是希望你更有利于对WebGL的理解。
如果有时间我会试着写一些关于如何实现三维效果的<a href="webgl-2d-translation.html">文章</a>，
讲一些一些关于WebGL的底层原理和细节。接下来可以考虑学习<a href="webgl-2-textures.html">如何使用多个纹理</a>。</p>

      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="http://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 进一步处理图像';
            var disqus_title = 'WebGL 进一步处理图像';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>基础概念</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
  </ul>
  <li>图像处理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
  </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
  </ul>
  <li>三维</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
  </ul>
  <li>光照</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL - Less Code, More Fun</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL - Drawing Multiple Things</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL - Scene Graphs</a></li>
  </ul>
  <li>Geometry</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 3D Geometry - Lathe</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 3D - Textures</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL - Using 2 or More Textures</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL - Cross Origin Images</a></li>
  </ul>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 2D - Matrix Stack</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL Text - HTML</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL Text - Canvas 2D</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL Text - Using a Texture</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL Text - Using a Glyph Texture</a>
    </ul>
  </ul>
  <li>杂项</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL Boilerplate</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL - Animation</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL and Alpha</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL - 2D vs 3D libraries</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



