<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-2-textures.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 使用多个纹理" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="在WebGL中如何使用多个纹理" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-2-textures.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 使用多个纹理" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/zh_cn/webgl-2-textures.html" />
<meta name="twitter:description" content="在WebGL中如何使用多个纹理" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 使用多个纹理</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 使用多个纹理</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>此文上接<a href="webgl-image-processing.html">WebGL 图像处理</a>，
如果没读建议<a href="webgl-image-processing.html">从那开始</a>。</p>
<p>现在可能是一个合适的时机去回答“如何使用 2 个或多个纹理？”。</p>
<p>非常简单，回到<a href="webgl-image-processing.html">几节之前绘制一个图像的着色器</a>，
将它升级到使用两个纹理。</p>
<p>首先改变代码加载两个图像，这其实不是WebGL的事情，是 HTML5
和 JavaScript 的事情，但是我也会涉及到。图像加载是异步的，可能需要适应一下。</p>
<p>基本上有两种方式来处理图像的加载，一种是重构代码，
让它在没有纹理的时候运行，当图像加载后，
再更新程序。我们会在以后的文章中用到这个方法。</p>
<p>这个例子中就等两个图像都加载完成后再开始绘制。</p>
<p>首先修改加载单个图像的方法，非常简单，
先创建一个新的 <code>Image</code> 对象，设置加载的url，然后设置回调函数在图像加载完成后调用。</p>
<pre><code>function loadImage(url, callback) {
  var image = new Image();
  image.src = url;
  image.onload = callback;
  return image;
}
</code></pre><p>现在来创建一个方法加载一个 URL 序列，并且创建一个图像序列。
首先设置 <code>imagesToLoad</code> 为加载图像的个数，然后为每个图像调用 <code>loadImage</code>，
当 <code>imagesToLoad</code> 递减到 0 的时候说明所有图像加载完成，调用回调函数。</p>
<pre><code>function loadImages(urls, callback) {
  var images = [];
  var imagesToLoad = urls.length;

  // 每个图像加载完成后调用一次
  var onImageLoad = function() {
    --imagesToLoad;
    // 如果所有图像都加载完成就调用回调函数
    if (imagesToLoad == 0) {
      callback(images);
    }
  };

  for (var ii = 0; ii &lt; imagesToLoad; ++ii) {
    var image = loadImage(urls[ii], onImageLoad);
    images.push(image);
  }
}
</code></pre><p>然后就可以像这样调用 loadImages</p>
<pre><code>function main() {
  loadImages([
    &quot;resources/leaves.jpg&quot;,
    &quot;resources/star.jpg&quot;,
  ], render);
}
</code></pre><p>接下来修改着色器使用两个纹理，在这个例子中我们将两个纹理相乘。</p>
<pre><code>&amp;lt;script id=&quot;2d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&amp;gt;
precision mediump float;

// 纹理
uniform sampler2D u_image0;
uniform sampler2D u_image1;

// 从顶点着色器传入的 texCoords
varying vec2 v_texCoord;

void main() {
   vec4 color0 = texture2D(u_image0, v_texCoord);
   vec4 color1 = texture2D(u_image1, v_texCoord);
   gl_FragColor = color0 * color1;
}
&amp;lt;/script&amp;gt;
</code></pre><p>需要创建两个WebGL纹理对象。</p>
<pre><code>  // 创建两个纹理
  var textures = [];
  for (var ii = 0; ii &lt; 2; ++ii) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // 设置参数以便使用任意尺的影像
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    // 上传图像到纹理
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[ii]);

    // 将纹理添加到纹理序列
    textures.push(texture);
  }
</code></pre><p>WebGL有一个叫做&quot;texture units&quot;的对象，你可以把它看成是一个纹理引用的序列，
你需要告诉着色器每个 sampler（取样器） 使用哪一个 texture unit（纹理单元）。</p>
<pre><code>  // 寻找取样器的位置
  var u_image0Location = gl.getUniformLocation(program, &quot;u_image0&quot;);
  var u_image1Location = gl.getUniformLocation(program, &quot;u_image1&quot;);

  ...

  // 设置使用的纹理单元
  gl.uniform1i(u_image0Location, 0);  // 纹理单元 0
  gl.uniform1i(u_image1Location, 1);  // 纹理单元 1
</code></pre><p>然后将每个纹理单元绑定纹理。</p>
<pre><code>  // 设置每个纹理单元对应一个纹理
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
</code></pre><p>使用的两个图像像这样</p>
<p><style>.glocal-center { text-align: center; } .glocal-center-content { margin-left: auto; margin-right: auto; }</style></p>
<div class="glocal-center"><table class="glocal-center-content"><tr><td><img src="../../resources/leaves.jpg" /> <img src="../../resources/star.jpg" /></td></tr></table></div>

<p>这就是使用WebGL将它们相乘的结果。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2-textures.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>有些需要回顾的部分。</p>
<p>理解纹理单元的简单方式是：所有的纹理方法可以在“激活的纹理单元”上使用，
“激活的纹理单元”就是一个全局变量指向你想使用的所有纹理单元，
每个纹理单元有两个目标对象，TEXTURE_2D 目标和 TEXTURE_CUBE_MAP 目标。
每个纹理方法针对激活纹理单元上的一个目标，如果用 JavaScript 表示 WebGL
方法可能像这样</p>
<pre><code>var getContext = function() {
  var textureUnits = [
    { TEXTURE_2D: ??, TEXTURE_CUBE_MAP: ?? },
    { TEXTURE_2D: ??, TEXTURE_CUBE_MAP: ?? },
    { TEXTURE_2D: ??, TEXTURE_CUBE_MAP: ?? },
    { TEXTURE_2D: ??, TEXTURE_CUBE_MAP: ?? },
    { TEXTURE_2D: ??, TEXTURE_CUBE_MAP: ?? },
    ...
  ];
  var activeTextureUnit = 0;

  var activeTexture = function(unit) {
    // 将纹理单元枚举转换成索引
    var index = unit - gl.TEXTURE0;
    // 设置激活纹理单元
    activeTextureUnit = index;
  };

  var bindTexture = function(target, texture) {
    // 设置激活纹理单元的目标对象纹理
    textureUnits[activeTextureUnit][target] = texture;
  };

  var texImage2D = function(target, ... args ...) {
    // 绑定对应纹理单元调用相应的方法
    var texture = textureUnits[activeTextureUnit][target];
    texture.image2D(...args...);
  };

  // 返回 WebGL API
  return {
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    texImage2D: texImage2D,
  }
};
</code></pre><p>着色器获得纹理单元</p>
<pre><code>  gl.uniform1i(u_image0Location, 0);  // 纹理单元 0
  gl.uniform1i(u_image1Location, 1);  // 纹理单元 1
</code></pre><p>需要注意的是，设置全局变量的时候使用索引代替纹理单元，但是调用 gl.activeTexture
的时候你需要传递特殊的常量gl.TEXTURE0, gl.TEXTURE1 之类。
幸运的是这些常量是连续的，所以这些代码</p>
<pre><code>  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
</code></pre><p>可以写成这样</p>
<pre><code>  gl.activeTexture(gl.TEXTURE0 + 0);
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  gl.activeTexture(gl.TEXTURE0 + 1);
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
</code></pre><p>或这样</p>
<pre><code>  for (var ii = 0; ii &lt; 2; ++ii) {
    gl.activeTexture(gl.TEXTURE0 + ii);
    gl.bindTexture(gl.TEXTURE_2D, textures[ii]);
  }
</code></pre><p>希望这样能够帮助你理解WebGL单次绘制中如何使用多个纹理。</p>

      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="http://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 使用多个纹理';
            var disqus_title = 'WebGL 使用多个纹理';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>基础概念</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
  </ul>
  <li>图像处理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
  </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
  </ul>
  <li>三维</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
  </ul>
  <li>光照</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
  </ul>
  <li>组织和重构</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
  </ul>
  <li>几何</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
  </ul>
  <li>纹理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>    
    <li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
  </ul>
  <li>渲染到纹理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
  </ul>
  <li>技术</li>
  <ul>
    <li>二维</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a>
    </ul>
    <li>文字</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a>
    </ul>
  </ul>
  <li>杂项</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL - Animation</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL and Alpha</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



