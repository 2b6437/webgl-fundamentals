<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-less-code-more-fun.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 码少趣多" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="让编写WebGL代码少点啰嗦" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/zh_cn/webgl-less-code-more-fun.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 码少趣多" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/zh_cn/webgl-less-code-more-fun.html" />
<meta name="twitter:description" content="让编写WebGL代码少点啰嗦" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 码少趣多</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-less-code-more-fun.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-less-code-more-fun.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-less-code-more-fun.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-less-code-more-fun.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-less-code-more-fun.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-less-code-more-fun.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-less-code-more-fun.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 码少趣多</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>此文上接WebGL系列文章，从<a href="webgl-fundamentals.html">基础理论</a>开始，
如果没读请从那里开始。</p>
<p>编写WebGL代码时，你需要将着色器对链接到程序中，然后找到输入变量的位置。
这些输入变量包括属性和全局变量，找到他们的位置非常啰唆和无聊。</p>
<p>假设我们有<a href="webgl-boilerplate.html">这样一个典型的WebGL着色程序模板</a>，
有这样一对着色器。</p>
<p>顶点着色器：</p>
<pre><code>uniform mat4 u_worldViewProjection;
uniform vec3 u_lightWorldPos;
uniform mat4 u_world;
uniform mat4 u_viewInverse;
uniform mat4 u_worldInverseTranspose;

attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

void main() {
  v_texCoord = a_texcoord;
  v_position = (u_worldViewProjection * a_position);
  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
  gl_Position = v_position;
}
</code></pre><p>片断着色器：</p>
<pre><code>precision mediump float;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_lightColor;
uniform vec4 u_ambient;
uniform sampler2D u_diffuse;
uniform vec4 u_specular;
uniform float u_shininess;
uniform float u_specularFactor;

vec4 lit(float l ,float h, float m) {
  return vec4(1.0,
              max(l, 0.0),
              (l &gt; 0.0) ? pow(max(0.0, h), m) : 0.0,
              1.0);
}

void main() {
  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);
  vec3 a_normal = normalize(v_normal);
  vec3 surfaceToLight = normalize(v_surfaceToLight);
  vec3 surfaceToView = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLight + surfaceToView);
  vec4 litR = lit(dot(a_normal, surfaceToLight),
                    dot(a_normal, halfVector), u_shininess);
  vec4 outColor = vec4((
  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +
                u_specular * litR.z * u_specularFactor)).rgb,
      diffuseColor.a);
  gl_FragColor = outColor;
}
</code></pre><p>你要在代码中像这样找到所有要设置的变量。</p>
<pre><code>// 初始化时
var u_worldViewProjectionLoc   = gl.getUniformLocation(program, &quot;u_worldViewProjection&quot;);
var u_lightWorldPosLoc         = gl.getUniformLocation(program, &quot;u_lightWorldPos&quot;);
var u_worldLoc                 = gl.getUniformLocation(program, &quot;u_world&quot;);
var u_viewInverseLoc           = gl.getUniformLocation(program, &quot;u_viewInverse&quot;);
var u_worldInverseTransposeLoc = gl.getUniformLocation(program, &quot;u_worldInverseTranspose&quot;);
var u_lightColorLoc            = gl.getUniformLocation(program, &quot;u_lightColor&quot;);
var u_ambientLoc               = gl.getUniformLocation(program, &quot;u_ambient&quot;);
var u_diffuseLoc               = gl.getUniformLocation(program, &quot;u_diffuse&quot;);
var u_specularLoc              = gl.getUniformLocation(program, &quot;u_specular&quot;);
var u_shininessLoc             = gl.getUniformLocation(program, &quot;u_shininess&quot;);
var u_specularFactorLoc        = gl.getUniformLocation(program, &quot;u_specularFactor&quot;);

var a_positionLoc              = gl.getAttribLocation(program, &quot;a_position&quot;);
var a_normalLoc                = gl.getAttribLocation(program, &quot;a_normal&quot;);
var a_texCoordLoc              = gl.getAttribLocation(program, &quot;a_texcoord&quot;);


// 初始化或绘制时需要的全局变量值
var someWorldViewProjectionMat = computeWorldViewProjectionMatrix();
var lightWorldPos              = [100, 200, 300];
var worldMat                   = computeWorldMatrix();
var viewInverseMat             = computeInverseViewMatrix();
var worldInverseTransposeMat   = computeWorldInverseTransposeMatrix();
var lightColor                 = [1, 1, 1, 1];
var ambientColor               = [0.1, 0.1, 0.1, 1];
var diffuseTextureUnit         = 0;
var specularColor              = [1, 1, 1, 1];
var shininess                  = 60;
var specularFactor             = 1;


// 绘制时
gl.useProgram(program);

// 设置所有的缓冲和属性
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.enableVertexAttribArray(a_positionLoc);
gl.vertexAttribPointer(a_positionLoc, positionNumComponents, gl.FLOAT, false, 0, 0);
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.enableVertexAttribArray(a_normalLoc);
gl.vertexAttribPointer(a_normalLoc, normalNumComponents, gl.FLOAT, false, 0, 0);
gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
gl.enableVertexAttribArray(a_texcoordLoc);
gl.vertexAttribPointer(a_texcoordLoc, texcoordNumComponents, gl.FLOAT, 0, 0);

// 设置使用的纹理
gl.activeTexture(gl.TEXTURE0 + diffuseTextureUnit);
gl.bindTexture(gl.TEXTURE_2D, diffuseTexture);

// 设置所有的全局变量
gl.uniformMatrix4fv(u_worldViewProjectionLoc, false, someWorldViewProjectionMat);
gl.uniform3fv(u_lightWorldPosLoc, lightWorldPos);
gl.uniformMatrix4fv(u_worldLoc, worldMat);
gl.uniformMatrix4fv(u_viewInverseLoc, viewInverseMat);
gl.uniformMatrix4fv(u_worldInverseTransposeLoc, worldInverseTransposeMat);
gl.uniform4fv(u_lightColorLoc, lightColor);
gl.uniform4fv(u_ambientLoc, ambientColor);
gl.uniform1i(u_diffuseLoc, diffuseTextureUnit);
gl.uniform4fv(u_specularLoc, specularColor);
gl.uniform1f(u_shininessLoc, shininess);
gl.uniform1f(u_specularFactorLoc, specularFactor);

gl.drawArrays(...);
</code></pre><p>需要写很多代码。</p>
<p>这有很多方式简化这个过程，
首先可以一次获取WebGL中需要的所有属性和全局变量的位置，
然后在一个方法中设置它们，我们可以传递一个JavaScript对象给这个方法。
如果理解了这一步操作，我们的代码应该会变成这样</p>
<pre><code>// 初始化时
var uniformSetters = webglUtils.createUniformSetters(gl, program);
var attribSetters  = webglUtils.createAttributeSetters(gl, program);

var attribs = {
  a_position: { buffer: positionBuffer, numComponents: 3, },
  a_normal:   { buffer: normalBuffer,   numComponents: 3, },
  a_texcoord: { buffer: texcoordBuffer, numComponents: 2, },
};

// 初始化或或绘制时需要的全局变量值
var uniforms = {
  u_worldViewProjection:   computeWorldViewProjectionMatrix(...),
  u_lightWorldPos:         [100, 200, 300],
  u_world:                 computeWorldMatrix(),
  u_viewInverse:           computeInverseViewMatrix(),
  u_worldInverseTranspose: computeWorldInverseTransposeMatrix(),
  u_lightColor:            [1, 1, 1, 1],
  u_ambient:               [0.1, 0.1, 0.1, 1],
  u_diffuse:               diffuseTexture,
  u_specular:              [1, 1, 1, 1],
  u_shininess:             60,
  u_specularFactor:        1,
};

// 绘制时
gl.useProgram(program);

// 设置所有的缓冲和属性
webglUtils.setAttributes(attribSetters, attribs);

// 设置需要的全局变量和纹理
webglUtils.setUniforms(uniformSetters, uniforms);

gl.drawArrays(...);
</code></pre><p>这样看起来就简单，清晰，代码量少一些了。</p>
<p>如果需要你也可以使用多个JavaScript对象，例如</p>
<pre><code>// 初始化时
var uniformSetters = webglUtils.createUniformSetters(gl, program);
var attribSetters  = webglUtils.createAttributeSetters(gl, program);

var attribs = {
  a_position: { buffer: positionBuffer, numComponents: 3, },
  a_normal:   { buffer: normalBuffer,   numComponents: 3, },
  a_texcoord: { buffer: texcoordBuffer, numComponents: 2, },
};

// 初始化或渲染时需要的全局变量
var uniformsThatAreTheSameForAllObjects = {
  u_lightWorldPos:         [100, 200, 300],
  u_viewInverse:           computeInverseViewMatrix(),
  u_lightColor:            [1, 1, 1, 1],
};

var uniformsThatAreComputedForEachObject = {
  u_worldViewProjection:   perspective(...),
  u_world:                 computeWorldMatrix(),
  u_worldInverseTranspose: computeWorldInverseTransposeMatrix(),
};

var objects = [
  { translation: [10, 50, 100],
    materialUniforms: {
      u_ambient:               [0.1, 0.1, 0.1, 1],
      u_diffuse:               diffuseTexture,
      u_specular:              [1, 1, 1, 1],
      u_shininess:             60,
      u_specularFactor:        1,
    },
  },
  { translation: [-120, 20, 44],
    materialUniforms: {
      u_ambient:               [0.1, 0.2, 0.1, 1],
      u_diffuse:               someOtherDiffuseTexture,
      u_specular:              [1, 1, 0, 1],
      u_shininess:             30,
      u_specularFactor:        0.5,
    },
  },
  { translation: [200, -23, -78],
    materialUniforms: {
      u_ambient:               [0.2, 0.2, 0.1, 1],
      u_diffuse:               yetAnotherDiffuseTexture,
      u_specular:              [1, 0, 0, 1],
      u_shininess:             45,
      u_specularFactor:        0.7,
    },
  },
];

// 绘制时
gl.useProgram(program);

// 设置所有对象公共部分的参数
webglUtils.setAttributes(attribSetters, attribs);
webglUtils.setUniforms(uniformSetters, uniformThatAreTheSameForAllObjects);

objects.forEach(function(object) {
  computeMatricesForObject(object, uniformsThatAreComputedForEachObject);
  webglUtils.setUniforms(uniformSetters, uniformThatAreComputedForEachObject);
  webglUtils.setUniforms(unifromSetters, objects.materialUniforms);
  gl.drawArrays(...);
});
</code></pre><p>这是使用这个辅助方法的一个例子</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-less-code-more-fun.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-less-code-more-fun.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>继续让代码更少一点，在之前的代码中我们用自己创建的缓冲设置 <code>attribs</code> ，
创建缓冲的代码没有列出来，假设你想创建一个位置，
法向量和纹理坐标的缓冲，你可能需要写这些代码</p>
<pre><code>// 一个三角形
var positions = [0, -10, 0, 10, 10, 0, -10, 10, 0];
var texcoords = [0.5, 0, 1, 1, 0, 1];
var normals   = [0, 0, 1, 0, 0, 1, 0, 0, 1];

var positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

var texcoordBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texcoordsBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);

var normalBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
</code></pre><p>看起来像是这种简化形式。</p>
<pre><code>// 一个三角形
var arrays = {
   position: { numComponents: 3, data: [0, -10, 0, 10, 10, 0, -10, 10, 0], },
   texcoord: { numComponents: 2, data: [0.5, 0, 1, 1, 0, 1],               },
   normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1],        },
};

var bufferInfo = createBufferInfoFromArrays(gl, arrays);
</code></pre><p>代码少多了！现在我们可以在渲染时这样写</p>
<pre><code>// 设置所有需要的缓冲和属性
webglUtils.setBuffersAndAttributes(gl, attribSetters, bufferInfo);

...

// 绘制几何体
gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-less-code-more-fun-triangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-less-code-more-fun-triangle.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>甚至在你使用索引时也可以这样做，<code>webglUtils.setBuffersAndAttributes</code>
会设置所有属性并使用你提供的 <code>indices</code> 设置 <code>ELEMENT_ARRAY_BUFFER</code>，
所以你需要调用 <code>gl.drawElements</code>。</p>
<pre><code>// 有索引的矩形
var arrays = {
   position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
   texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
   normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
   indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
};

var bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);
</code></pre><p>在渲染时将调用 <code>gl.drawElements</code> 代替 <code>gl.drawArrays</code>。</p>
<pre><code>// 设置所有需要的缓冲和属性
webglUtils.setBuffersAndAttributes(gl, attribSetters, bufferInfo);

...

// 绘制几何体
gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-less-code-more-fun-quad.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-less-code-more-fun-quad.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p><code>createBufferInfoFromArrays</code>方法本质上创建了类似这样的一个对象</p>
<pre><code> bufferInfo = {
   numElements: 4,        // 或者其他元素的实际个数
   indices: WebGLBuffer,  // 如果没有索引这个属性就不存在
   attribs: {
     a_position: { buffer: WebGLBuffer, numComponents: 3, },
     a_normal:   { buffer: WebGLBuffer, numComponents: 3, },
     a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },
   },
 };
</code></pre><p>然后 <code>webglUtils.setBuffersAndAttributes</code> 使用通过这个对象设置所有的缓冲和属性。</p>
<p>最后是我认为的最后一步，假定 <code>position</code> 总是有三个单位长度 (x, y, z)，
<code>texcoords</code> 总是有 2 个单位长度，索引 3 个单位长度，法向量 3 个单位长度，
然后让程序推测出单元的个数。</p>
<pre><code>// 有索引的矩形
var arrays = {
   position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
   texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
   normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
   indices:  [0, 1, 2, 1, 2, 3],
};
</code></pre><p>对应版本</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-less-code-more-fun-quad-guess.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-less-code-more-fun-quad-guess.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>我不确定哪个方式更好，因为推测有何很出出错。
例如我想在纹理坐标中添加一个单位长度存储其他信息，
按照 2 个单位去推测单元个数就会出错。当然，
如果出错了我可以像前一个例子中那样声明单元个数，取决于个人。
有些人喜欢事情按照他们的思路实现，越简单越好。</p>
<p>为什么不按照属性在着色器中的类型来确定单元的个数？
因为当我们使用 <code>vec4</code> 时大多数情况下只从缓冲中提供 3 个单位长度的数据  (x, y, z)，
WebGL会自动设置 <code>w = 1</code>。所以这就意味着我们不能轻易推断出用户的真实意愿，
因为他们在着色器中定义的单位长度可能和提供的长度不相符。</p>
<p>还有这样一个形式</p>
<pre><code>var program = webglUtils.createProgramFromScripts(gl, [&quot;vertexshader&quot;, &quot;fragmentshader&quot;]);
var uniformSetters = webglUtils.createUniformSetters(gl, program);
var attribSetters  = webglUtils.createAttributeSetters(gl, program);
</code></pre><p>可以简化成这样</p>
<pre><code>var programInfo = webglUtils.createProgramInfo(gl, [&quot;vertexshader&quot;, &quot;fragmentshader&quot;]);
</code></pre><p>返回类似这样的对象</p>
<pre><code>programInfo = {
   program: WebGLProgram,  // 刚编译的程序
   uniformSetters: ...,    // webglUtils.createUniformSetters 返回的 setter
   attribSetters: ...,     // webglUtils.createAttribSetters 返回的 setter
}
</code></pre><p>这是一个简单的简化，但是如果在多程序的代码中，就可以保持程序和对应的 setter 一致。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-less-code-more-fun-quad-programinfo.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-less-code-more-fun-quad-programinfo.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>总之，这是我在写WebGL程序时喜欢的模式，这些教程中的例子我会使用标准的
<strong>啰唆</strong>的方式，这样就不会让别人因为我自己的模式感到迷惑。
在某些时候标准形式过于复杂，所以在接下来的课程中可能会使用这种模式。</p>
<p>你也可以在你的代码中使用这种风格，例子中使用的方法 <code>createUniformSetters</code>,
 <code>createAttributeSetters</code>, <code>createBufferInfoFromArrays</code>, <code>setUniforms</code>,
和 <code>setBuffersAndAttributes</code> 都在 <a href="https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js"><code>webgl-utils.js</code></a>中。
如果你想更有组织的使用，可以看看 <a href="http://twgljs.org">TWGL.js</a>。</p>
<p>接下来，<a href="webgl-drawing-multiple-things.html">绘制多个物体</a>。</p>
<div class="webgl_bottombar">
<h3>我们能直接使用 setter 么?</h3>
<p>
熟悉JavaScript的人可能会想，我能像这样直接使用 setter 么？
</p>
<pre class="prettyprint">
// 初始化时
var uniformSetters = webglUtils.createUniformSetters(program);

// 绘制时
uniformSetters.u_ambient([1, 0, 0, 1]); // 设置环境光为红色
</pre>
<p>这样做不好的原因就是，在使用GLSL的过程中经常会修改，调试。假设屏幕上什么都没有出现，首先我会简化着色器，例如我会尽可能简化片断着色器。</p>
<pre class="prettyprint showlinemods">
// 片断着色器
precision mediump float;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_lightColor;
uniform vec4 u_ambient;
uniform sampler2D u_diffuse;
uniform vec4 u_specular;
uniform float u_shininess;
uniform float u_specularFactor;

vec4 lit(float l ,float h, float m) {
  return vec4(1.0,
              max(l, 0.0),
              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
              1.0);
}

void main() {
  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);
  vec3 a_normal = normalize(v_normal);
  vec3 surfaceToLight = normalize(v_surfaceToLight);
  vec3 surfaceToView = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLight + surfaceToView);
  vec4 litR = lit(dot(a_normal, surfaceToLight),
                    dot(a_normal, halfVector), u_shininess);
  vec4 outColor = vec4((
  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +
                u_specular * litR.z * u_specularFactor)).rgb,
      diffuseColor.a);
  gl_FragColor = outColor;
*  gl_FragColor = vec4(0,1,0,1);  // &lt;!--- 就是绿色
}
</pre>
<p>注意到我添加了一行，直接将 <code>gl_FragColor</code> 设置为固定颜色。
大多数驱动会发现之前的行没有为结果做贡献，优化后就会把没用的变量移除，
下次我运行程序调用<code>createUniformSetters</code>就不会为<code>u_ambient</code>
创建 setter，所以 <code>uniformSetters.u_ambient()</code> 就会报错。
<pre class="prettyprint">
TypeError: undefined is not a function
</pre>
<p><code>setUniforms</code> 可以避免这种错误，它只会设置存在的全局变量。</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-less-code-more-fun.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-less-code-more-fun.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-less-code-more-fun.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-less-code-more-fun.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-less-code-more-fun.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-less-code-more-fun.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-less-code-more-fun.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>
  <li>基础概念</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
  </ul>
  <li>图像处理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
  </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
  </ul>
  <li>三维</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
  </ul>
  <li>光照</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
  </ul>
  <li>组织和重构</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
  </ul>
  <li>几何</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
  </ul>
  <li>纹理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
  </ul>
  <li>渲染到纹理</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
  </ul>
  <li>技术</li>
  <ul>
    <li>二维</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a>
    </ul>
    <li>三维</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a>
    </ul>
    <li>文字</li>
    <ul>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a>
      <li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a>
    </ul>
  </ul>
  <li>杂项</li>
  <ul>
    <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
    <li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="http://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">GitHub</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="http://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 码少趣多';
            var disqus_title = 'WebGL 码少趣多';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



