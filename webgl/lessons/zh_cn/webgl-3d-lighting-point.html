<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-3d-lighting-point.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 三维点光源" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="如何在WebGL中实现点光源" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-lighting-point.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 三维点光源" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-lighting-point.html" />
<meta name="twitter:description" content="如何在WebGL中实现点光源" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 三维点光源</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-point.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-lighting-point.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-point.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-point.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-lighting-point.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-point.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-lighting-point.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 三维点光源</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>此文上接<a href="webgl-3d-lighting-directional.html">WebGL三维方向光源</a>，
如果没看请<a href="webgl-3d-lighting-directional.html">从那里开始</a>。</p>
<p>上篇中说到方向光统一来自一个方向，在渲染前设置好方向。</p>
<p>如果代替方向而是从三维空间中选一个点当作光源，
然后在着色器中根据光源和表面位置计算光照方向的话，就是点光源了。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example noborder" style="width: 500px; height: 400px;" src="/webgl/lessons/resources/point-lighting.html"></iframe>
</div>

</p>
<p>如果旋转上方的表面会发现，每个点都有一个不同的<strong>面到光源</strong>的矢量，
将这个矢量和法向量点乘后，表面上的每个点都会有一个不同的光照值。</p>
<p>让我们实现它吧。</p>
<p>首先需要一个光源位置</p>
<pre class="prettyprint"><code>uniform vec3 u_lightWorldPosition;
</code></pre><p>然后需要计算表面的世界坐标，我们可以将位置和世界矩阵相乘得到...</p>
<pre class="prettyprint"><code>uniform mat4 u_world;

...

// 计算表面的世界坐标
vec3 surfaceWorldPosition = (u_world * a_position).xyz;
</code></pre><p>然后可以计算出一个从表面到光源的矢量，用来模拟之前的方向光，
只是这次我们为表面上的每个点都计算了一个方向。</p>
<pre class="prettyprint"><code>v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
</code></pre><p>这是全部的内容</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
attribute vec3 a_normal;

+uniform vec3 u_lightWorldPosition;

+uniform mat4 u_world;
uniform mat4 u_worldViewProjection;
uniform mat4 u_worldInverseTranspose;

varying vec3 v_normal;

+varying vec3 v_surfaceToLight;

void main() {
  // 将位置和矩阵相乘
  gl_Position = u_worldViewProjection * a_position;

  // 重定向法向量并传递给片断着色器
  v_normal = mat3(u_worldInverseTranspose) * a_normal;

+  // 计算表面的世界坐标
+  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
+
+  // 计算表面到光源的方向
+  // 传递给片断着色器
+  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
}
</code></pre><p>在片断着色器中需要将表面到光源的方向进行单位化，
注意，虽然我们可以在顶点着色器中传递单位向量，
但是 <code>varying</code> 会进行插值再传给片断着色器，
所以片断着色器中的向量基本上不是单位向量了。</p>
<pre class="prettyprint"><code>precision mediump float;

// 从顶点着色器中传入的值
varying vec3 v_normal;
+varying vec3 v_surfaceToLight;

-uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;

void main() {
  // 由于 v_normal 是可变量，所以经过插值后不再是单位向量，
  // 单位化后会成为单位向量
  vec3 normal = normalize(v_normal);

  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);

  -float light = dot(v_normal, u_reverseLightDirection);
  +float light = dot(v_normal, surfaceToLightDirection);

  gl_FragColor = u_color;

  // 只将颜色部分（不包含 alpha） 和光照相乘
  gl_FragColor.rgb *= light;
}
</code></pre><p>然后需要找到 <code>u_world</code> 和 <code>u_lightWorldPosition</code> 的位置</p>
<pre class="prettyprint"><code>-  var reverseLightDirectionLocation =
-      gl.getUniformLocation(program, &quot;u_reverseLightDirection&quot;);
+  var lightWorldPositionLocation =
+      gl.getUniformLocation(program, &quot;u_lightWorldPosition&quot;);
+  var worldLocation =
+      gl.getUniformLocation(program, &quot;u_world&quot;);
</code></pre><p>设置它们</p>
<pre class="prettyprint"><code>  // 设置矩阵
+  gl.uniformMatrix4fv(
+      worldLocation, false,
+      worldMatrix);
  gl.uniformMatrix4fv(
      worldViewProjectionLocation, false,
      worldViewProjectionMatrix);

  ...

-  // 设置光照方向
-  gl.uniform3fv(reverseLightDirectionLocation, m4.normalize([0.5, 0.7, 1]));
+  // 设置光源位置
+  gl.uniform3fv(lightWorldPositionLocation, [20, 30, 50]);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-point.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-point.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>现在我们可以加一个叫做镜面高光的东西。</p>
<p>观察现实世界中的物体，如果物体表面恰好将光线反射到你眼前，
就会显得非常明亮，像镜子一样。</p>
<p><img class="webgl_center" src="../resources/specular-highlights.jpg" /></p>
<p>我们可以通过计算光线是否反射到眼前来模拟这种情况，<strong>点乘</strong>又一次起到了至关重要的作用。</p>
<p>如何测试呢？如果入射角和反射角恰好与眼睛和和光源的夹角相同，那么光线就会反射到眼前。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example noborder" style="width: 500px; height: 400px;" src="/webgl/lessons/resources/surface-reflection.html"></iframe>
</div>

</p>
<p>如果我们知道了物体表面到光源的方向（刚刚已经计算过了），
加上物体表面到视区/眼睛/相机的方向，再除以 2 得到 <code>halfVector</code> 向量，
将这个向量和法向量比较，如果方向一致，那么光线就会被反射到眼前。
那么如何确定方向是否一致呢？用之前的<strong>点乘</strong>就可以了。1 表示相符，
0 表示垂直，-1 表示相反。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example noborder" style="width: 500px; height: 400px;" src="/webgl/lessons/resources/specular-lighting.html"></iframe>
</div>

</p>
<p>所以首先我们需要传入相机位置，计算表面到相机的方向矢量，
然后传递到片断着色器。</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
attribute vec3 a_normal;

uniform vec3 u_lightWorldPosition;
+uniform vec3 u_viewWorldPosition;

uniform mat4 u_world;
uniform mat4 u_worldViewProjection;
uniform mat4 u_worldInverseTranspose;

varying vec3 v_normal;

varying vec3 v_surfaceToLight;
+varying vec3 v_surfaceToView;

void main() {
  // 将位置和矩阵相乘
  gl_Position = u_worldViewProjection * a_position;

  // 重定向法向量并传递到片断着色器
  v_normal = mat3(u_worldInverseTranspose) * a_normal;

  // 计算表面的世界坐标
  vec3 surfaceWorldPosition = (u_world * a_position).xyz;

  // 计算表面到光源的方向
  // 然后传递到片断着色器
  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

+  // 计算表面到相机的方向
+  // 然后传递到片断着色器
+  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
</code></pre><p>然后在片断着色器中计算表面到光源和相机之间的 <code>halfVector</code>，
将它和法向量相乘，查看光线是否直接反射到眼前。</p>
<pre class="prettyprint"><code>// 从顶点着色器中传入的值
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
+varying vec3 v_surfaceToView;

uniform vec4 u_color;

void main() {
  // 由于 v_normal 是可变量，所以经过插值后不再是单位向量，
  // 单位化后会成为单位向量
  vec3 normal = normalize(v_normal);

+  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
+  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
+  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

  float light = dot(normal, surfaceToLightDirection);
+  float specular = dot(normal, halfVector);

  gl_FragColor = u_color;

  // 只将颜色部分（不包含 alpha） 和光照相乘
  gl_FragColor.rgb *= light;

+  // 直接加上高光
+  gl_FragColor.rgb += specular;
}
</code></pre><p>最后找到 <code>u_viewWorldPosition</code> 并设置它</p>
<pre class="prettyprint"><code>var lightWorldPositionLocation =
    gl.getUniformLocation(program, &quot;u_lightWorldPosition&quot;);
+var viewWorldPositionLocation =
+    gl.getUniformLocation(program, &quot;u_viewWorldPosition&quot;);

...

// 计算相机矩阵
var camera = [100, 150, 200];
var target = [0, 35, 0];
var up = [0, 1, 0];
var cameraMatrix = makeLookAt(camera, target, up);

+// 设置相机位置
+gl.uniform3fv(viewWorldPositionLocation, camera);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-point-specular.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-point-specular.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p><strong>但，亮瞎了!</strong></p>
<p>我们可以将点乘结果进行求幂运算来解决太亮的问题，
它会把高光从线性变换变成指数变换。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example noborder" style="width: 300px; height: 300px;" src="/webgl/lessons/resources/power-graph.html"></iframe>
</div>

</p>
<p>红线越接近顶部，我们加的光照就越多，通过求幂可以将高光的部分向右移动。</p>
<p>就把它叫做 <code>shininess</code> 并加到着色器中。</p>
<pre class="prettyprint"><code>uniform vec4 u_color;
+uniform float u_shininess;

...

-  float specular = dot(normal, halfVector);
+  float specular = 0.0;
+  if (light &gt; 0.0) {
+    specular = pow(dot(normal, halfVector), u_shininess);
+  }
</code></pre><p>点乘结果有可能为负值，将赋值求幂有可能会得到 undefined 的结果，
所以我们只将点乘结果为正的部分进行计算，其他部分设置为 0.0。</p>
<p>当然还要找到亮度的位置并设置它</p>
<pre class="prettyprint"><code>+var shininessLocation = gl.getUniformLocation(program, &quot;u_shininess&quot;);

...

// 设置亮度
gl.uniform1f(shininessLocation, shininess);
</code></pre><p>这是结果</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-point-specular-power.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-point-specular-power.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>最后想说的是光的颜色。</p>
<p>在此之前我们都是将 <code>light</code> 和 F 的颜色直接相乘，
如果想要有色光也可以为光照提供颜色。</p>
<pre class="prettyprint"><code>uniform vec4 u_color;
uniform float u_shininess;
+uniform vec3 u_lightColor;
+uniform vec3 u_specularColor;

...

  // 只将颜色部分（不包含 alpha） 和光照相乘
*  gl_FragColor.rgb *= light * u_lightColor;

  // 直接和高光相加
*  gl_FragColor.rgb += specular * u_specularColor;
}
</code></pre><p>然后</p>
<pre class="prettyprint"><code>+  var lightColorLocation =
+      gl.getUniformLocation(program, &quot;u_lightColor&quot;);
+  var specularColorLocation =
+      gl.getUniformLocation(program, &quot;u_specularColor&quot;);
</code></pre><p>和</p>
<pre class="prettyprint"><code>// 设置光照颜色
+  gl.uniform3fv(lightColorLocation, m4.normalize([1, 0.6, 0.6]));  // 红光
// 设置高光颜色
+  gl.uniform3fv(specularColorLocation, m4.normalize([1, 0.6, 0.6]));  // 红光
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-point-color.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-point-color.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>接下来是？？？</p>
<div class="webgl_bottombar">
<h3>为什么 <code>pow(negative, power)</code> 是 undefined?</h3>
<p>它是什么意思?</p>
<div class="webgl_center"><pre class="glocal-center-content">pow(5, 2)</pre></div>
<p>你可以当作</p>
<div class="webgl_center"><pre class="glocal-center-content">5 * 5 = 25</pre></div>
<p>然后</p>
<div class="webgl_center"><pre class="glocal-center-content">pow(5, 3)</pre></div>
<p>可以看作是</p>
<div class="webgl_center"><pre class="glocal-center-content">5 * 5 * 5 = 125</pre></div>
<p>那么</p>
<div class="webgl_center"><pre class="glocal-center-content">pow(-5, 2)</pre></div>
<p>就是</p>
<div class="webgl_center"><pre class="glocal-center-content">-5 * -5 = 25</pre></div>
<p>然后</p>
<div class="webgl_center"><pre class="glocal-center-content">pow(-5, 3)</pre></div>
<p>就成为</p>
<div class="webgl_center"><pre class="glocal-center-content">-5 * -5 * -5 = -125</pre></div>
<p>你可能知道负数和负数相乘就会变成正数，再乘以负数就会变成负数。</p>
<p>那么这是什么意思呢?</p>
<div class="webgl_center"><pre class="glocal-center-content">pow(-5, 2.5)</pre></div>
<p>你如何决定这是正数还是负数？我数学并不好但是这看起来很难确定所以就是 undefined。</p>.
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-point.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-lighting-point.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-point.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-point.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-lighting-point.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-point.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-lighting-point.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">undefined</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="http://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl">在Stackoverflow提问</a>。</div>
        <div>有意见或建议? <a href="http://github.com/vinci-mz/webgl-fundamentals/issues">在GitHub上提issue</a>。</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 三维点光源';
            var disqus_title = 'WebGL 三维点光源';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



