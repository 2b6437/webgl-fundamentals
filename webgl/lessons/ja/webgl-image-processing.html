<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ja/webgl-image-processing.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGLにおける画像処理" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="WebGLで画像の加工処理をするには" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/ja/webgl-image-processing.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGLにおける画像処理" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/ja/webgl-image-processing.html" />
<meta name="twitter:description" content="WebGLで画像の加工処理をするには" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGLにおける画像処理</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGLにおける画像処理</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>WebGLでは、画像の加工処理は簡単です。どれくらい簡単かって？続きを読んでください。
<!--more-->
この記事は、「<a href="webgl-fundamentals.html">WebGLの基礎</a>」の続きです。
あらかじめ「<a href="webgl-fundamentals.html">WebGLの基礎</a>」を読むことをお勧めします。</p>
<p>WebGLで画像を描く場合、テクスチャを使う必要があります。
WebGLでレンダリングする際には、ピクセル単位ではなく「クリッピング空間」での座標を指定しますが、
これと同じように、テクスチャを描く際には「テクスチャ座標」を使用します。
テクスチャ座標は、テクスチャのサイズに関わらず0.0から1.0の数値で指定します。</p>
<p>長方形を描く場合(はい。WebGLだから正確には「２つの三角形を描く場合」ですね)、
「テクスチャのどの部分が、長方形のどの部分に対応するのか」という情報を、WebGLに教える必要があります。
頂点シェーダーからフラグメントシェーダーへこの情報を渡す際には、
「varying」と呼ばれる特殊な変数を使用します。varyとは英語で「可変」といった意味です。
フラグメントシェーダーで各ピクセルを描く際には、頂点シェーダに与えた情報をWebGLが「補間(interpolate)」します。</p>
<p><a href="webgl-fundamentals.html">以前の記事の使った頂点シェーダーの最終版</a>を元にして、新たにテクスチャを使いたい場合、
「テクスチャ座標を頂点シェーダーにアトリビュートとして与える仕組み」と、
さらに「それを頂点シェーダーからフラグメントシェーダーに渡す仕組み」を追加する必要があります。</p>
<pre><code>attribute vec2 a_texCoord;
...
varying vec2 v_texCoord;

void main() {
   ...
   // texCoordをフラグメントシェーダーに渡す。
   // この時、GPUは長方形の各頂点の間の部分を補間して塗りつぶす。
   v_texCoord = a_texCoord;
}
</code></pre><p>頂点シェーダーを変更したら、今度はフラグメントシェーダー側を、
「描くべき色を、テクスチャを参照して判断する」ように変更しましょう。</p>
<pre><code>&lt;script id=&quot;2d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

// これが今回使うテクスチャ
uniform sampler2D u_image;

// 頂点シェーダーから渡された、頂点座標が入った「texCoords」
varying vec2 v_texCoord;

void main() {
   // テクスチャを参照して、今描くべきピクセルの色を取り出す
   gl_FragColor = texture2D(u_image, v_texCoord);
}
&lt;/script&gt;
</code></pre><p>２つのシェーダーが用意できたら、今度は「画像をロード」して「テクスチャを作成」して
「テクスチャへ画像をコピー」する仕組みが必要です。
ブラウザーでは、画像のロードは非同期に行われるので、画像のロード完了を待つための
ちょっとした仕組みが必要になります。描画するのは、画像のロードが完了した後でなければなりません。</p>
<pre><code>function main() {
  var image = new Image();
  image.src = &quot;http://someimage/on/our/server&quot;;  // 同じドメインじゃないとダメ！
  image.onload = function() {
    render(image);
  }
}

function render(image) {
  ...
  // 前に書いたコード全部をここに書く……
  ...
  // 「テクスチャ座標」情報を送る先を指定する
  var texCoordLocation = gl.getAttribLocation(program, &quot;a_texCoord&quot;);

  // 長方形の各頂点とテクスチャ座標の対応付けを定義する
  var texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0.0,  0.0,
      1.0,  0.0,
      0.0,  1.0,
      0.0,  1.0,
      1.0,  0.0,
      1.0,  1.0]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texCoordLocation);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

  // テクスチャオブジェクトを生成する
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // どんなサイズの画像でもレンダリングできるようにパラメータを設定する
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  // テクスチャオブジェクトに画像のデータをアップロードする
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  ...
}
</code></pre><p>以上で、WebGLで画像がレンダリングできるようになりました。
注意：ローカルで動かす場合は、WebGLが画像をロードできるようにするために何らかのWebサーバーを動かす必要があります。
この設定は<a href="webgl-setup-and-installation.html">数分の作業でできます</a>。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-image.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-image.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>おもしろみがない？ちょっと軽く赤と青を入れ替えてみます？</p>
<pre><code>...
gl_FragColor = texture2D(u_image, v_texCoord).bgra;
...
</code></pre><p>赤と青を入れ替えてみました。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-image-red2blue.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-image-red2blue.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>いま描いているピクセルだけでなく、「ほかのピクセル」の情報も使うような加工の場合はどうでしょうか？
WebGLはテクスチャを参照する際、0.0から1.0の値を取る「テクスチャ座標」を使用しているので、
元画像で１ピクセル移動するためにテクスチャ座標の数値をどれだけ移動すれば良いかは、
<code>onePixel = 1.0 / textureSize</code>といったコードで知ることができます。</p>
<p>このコードは、「左右１ピクセルを見てその平均の色で描く」というフラグメントシェーダーです。</p>
<pre><code>&lt;script id=&quot;2d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

// 今回使うテクスチャ
uniform sampler2D u_image;
uniform vec2 u_textureSize;

// 頂点シェーダーから渡された、頂点座標が入った「texCoords」
varying vec2 v_texCoord;

void main() {
   // １ピクセル分の、テクスチャ座標での大きさを求める
   vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;

   // 左のピクセル、今のピクセル、右のピクセルの色の平均値を求める
   gl_FragColor = (
       texture2D(u_image, v_texCoord) +
       texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +
       texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))) / 3.0;
}
&lt;/script&gt;
</code></pre><p>そしてJavaScriptからは、テクスチャサイズの情報を渡します。</p>
<pre><code>...

var textureSizeLocation = gl.getUniformLocation(program, &quot;u_textureSize&quot;);

...

// 画像のサイズをセット
gl.uniform2f(textureSizeLocation, image.width, image.height);

...
</code></pre><p>これで、隣のピクセルの色の情報を使って「ぼかし」が表現できました。上の画像と比べてみてください。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-image-blend.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-image-blend.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>さて、「ほかのピクセル」を参照する方法がわかったので、今度は「畳み込み行列(convolution kernel)」を
使ってもっと応用的汎用的に画像処理をやってみましょう。ここでは、3x3の行列(カーネル)を使ってみます。
「畳み込み行列」は、ピクセルを描画する際に「縦横斜めに隣り合った周辺８ピクセルの値をそれぞれ何倍するか」、
「3x3の行列で指定する」という仕組みです。ウェイト(カーネルの全要素の値の合計)が1.0の場合と、
それより大きい場合では分けて考えます。
We then divide the result by the weight of the kernel (the sum of all values in the kernel) or 1.0,
whichever is greater.
畳み込み行列については、<a href="http://docs.gimp.org/en/plug-in-convmatrix.html">この記事がお勧めです</a>
(<a href="https://docs.gimp.org/ja/plug-in-convmatrix.html">日本語版</a>)。
また、<a href="http://www.codeproject.com/KB/graphics/ImageConvolution.aspx">この記事ではC++で実装したコードが見られます</a>。</p>
<p>以上の仕組みを実装したフラグメントシェーダーを書いてみます。</p>
<pre><code>&lt;script id=&quot;2d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

// 今回使うテクスチャ
uniform sampler2D u_image;
uniform vec2 u_textureSize;
uniform float u_kernel[9];
uniform float u_kernelWeight;

// 頂点シェーダーから渡された、頂点座標が入った「texCoords」
varying vec2 v_texCoord;

void main() {
   vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
   vec4 colorSum =
     texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +
     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +
     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +
     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;

   // Divide the sum by the weight but just use rgb
   // 透明度は1.0とする
   gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, 1.0);
}
&lt;/script&gt;
</code></pre><p>JavaScript側からは、畳み込み行列とそのウェイトの情報をシェーダーに送ります。</p>
<pre><code> function computeKernelWeight(kernel) {
   var weight = kernel.reduce(function(prev, curr) {
       return prev + curr;
   });
   return weight &lt;= 0 ? 1 : weight;
 }

 ...
 var kernelLocation = gl.getUniformLocation(program, &quot;u_kernel[0]&quot;);
 var kernelWeightLocation = gl.getUniformLocation(program, &quot;u_kernelWeight&quot;);
 ...
 var edgeDetectKernel = [
     -1, -1, -1,
     -1,  8, -1,
     -1, -1, -1
 ];
 gl.uniform1fv(kernelLocation, edgeDetectKernel);
 gl.uniform1f(kernelWeightLocation, computeKernelWeight(edgeDetectKernel));
 ...
</code></pre><p>これで、完成……。下の例では、ドロップリストでほかのカーネルを選択できます。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-image-3x3-convolution.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-image-3x3-convolution.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>WebGLでの画像処理がどれほど簡単か、おわかりいただけたのではないでしょうか。
次は、<a href="webgl-image-processing-continued.html">２つ以上のエフェクトをかける</a>ことに挑戦しましょう。</p>
<div class="webgl_bottombar">
<h3><code>u_image</code>に値をセットしていないよ。どうなるの？</h3>
<p>
Uniform変数のデフォルト値は0、という決まりがあるので、テクスチャユニット0が選択されます。
テクスチャユニット0はデフォルトのアクティブテクスチャでもあるため、
bindTextureメソッドが呼ばれた際にはテクスチャユニット0がバインドされます。
</p>
<p>
WebGLにはテクスチャユニットの配列があります。
uniform型の各サンプラー変数がどのテクスチャユニットを参照するかを指定するには、
まず「サンプラー変数のロケーションを得て」、それに対して「目的のテクスチャユニットのインデックスを指定」します。
</p>
<p>
例：
</p>
<pre class="prettyprint showlinemods">
var textureUnitIndex = 6; // テクスチャユニット６を使う。
var u_imageLoc = gl.getUniformLocation(
    program, "u_image");
gl.uniform1i(u_imageLoc, textureUnitIndex);
</pre>
<p>
別のユニットのテクスチャを使いたい場合は、<code>gl.activeTexture</code>を呼び、
そのユニットのテクスチャをバインドします。例は以下のとおり。
</p>
<pre class="prettyprint showlinemods">
// テクスチャ「someTexture」を、テクスチャユニット６のテクスチャにバインドする。
gl.activeTexture(gl.TEXTURE6);
gl.bindTexture(gl.TEXTURE_2D, someTexture);
</pre>
<p>
こんな書き方もできます。
</p>
<pre class="prettyprint showlinemods">
var textureUnitIndex = 6; // テクスチャユニット６を使う。
// テクスチャ「someTexture」を、テクスチャユニット６のテクスチャにバインドする。
gl.activeTexture(gl.TEXTURE0 + textureUnitIndex);
gl.bindTexture(gl.TEXTURE_2D, someTexture);
</pre>
<p>
WebGLの仕様では、すべてのWebGL実装は最低８個のテクスチャユニットを
サポートする必要があります(フラグメントシェーダーの場合８個。頂点シェーダーで必須とされているテクスチャユニットは０個です)。
８つより多くのテクスチャユニットを使いたい場合は、あらかじめ
<code>gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)</code>メソッドを呼んで利用可能な数を確認するべきです。
頂点シェーダーでテクスチャを扱いたい場合は、
<code>gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)</code>を呼んで利用可能な数を確認します。
実際のWebGLの実装では99%が、頂点シェーダにおいて最低４つのテクスチャユニットをサポートしています。
</p>
</div>

<div class="webgl_bottombar">
<h3>GLSLコードでa_, u_, v_とかで始まる変数があるけどこれは何？</h3>
<p>
ただの命名規則の話です。文法上必要な規則ではないのですが、私は、
そういった名前にしておくとその変数がどこから来たのか見やすいのでそうしています。
こうしておけば、a_で始まる変数はアトリビュートでバッファーから持ってきたデータ、
u_はシェーダー共通のユニフォーム変数、
v_はvarying変数で頂点シェーダーからフラグメントシェーダーに送られたもので描画時に頂点間が補間されている、といったことが一目でわかります。
各変数の意味や仕組みについては「<a href="webgl-how-it-works.html">WebGLの仕組み</a>」で説明しているので、参考にしてください。
</p>
</div>



      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>質問? <a href="http://stackoverflow.com/questions/tagged/webgl">stackoverflowで質問(英語)</a>.</div>
        <div>問題点/バグ? <a href="http://github.com/greggman/webgl-fundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGLにおける画像処理';
            var disqus_title = 'WebGLにおける画像処理';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>基本</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-fundamentals.html">WebGLの基本</a></li>
    <li><a href="/webgl/lessons/ja/webgl-how-it-works.html">WebGLの仕組み</a></li>
    <li><a href="/webgl/lessons/ja/webgl-shaders-and-glsl.html">WebGL Shaders and GLSL(英語)</a></li>
  </ul>
  <li>画像処理</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-image-processing.html">WebGLにおける画像処理</a></li>
    <li><a href="/webgl/lessons/ja/webgl-image-processing-continued.html">WebGLにおける画像処理。続き</a></li>
  </ul>
  <li>2Dでの移動、回転、拡大縮小、行列計算</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-2d-translation.html">WebGL - 二次元での移動</a></li>
    <li><a href="/webgl/lessons/ja/webgl-2d-rotation.html">WebGL - 二次元での回転</a></li>
    <li><a href="/webgl/lessons/ja/webgl-2d-scale.html">WebGL - 二次元での拡大縮小</a></li>
    <li><a href="/webgl/lessons/ja/webgl-2d-matrices.html">WebGL - 二次元での行列数学</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-3d-orthographic.html">WebGL三次元の正投影</a></li>
    <li><a href="/webgl/lessons/ja/webgl-3d-perspective.html">WebGL三次元透視投影</a></li>
    <li><a href="/webgl/lessons/ja/webgl-3d-camera.html">WebGL三次元のカメラ</a></li>
  </ul>
  <li>Lighting</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-3d-lighting-directional.html">WebGL 3D - Directional Lighting(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-3d-lighting-point.html">WebGL 3D - Point Lighting(英語)</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-less-code-more-fun.html">WebGL - Less Code, More Fun(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-drawing-multiple-things.html">WebGL - Drawing Multiple Things(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-scene-graph.html">WebGL - Scene Graphs(英語)</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-3d-textures.html">WebGL 3D - Textures(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-data-textures.html">WebGL Data Textures(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-2-textures.html">WebGL - Using 2 or More Textures(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-cors-permission.html">WebGL - Cross Origin Images(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Perspective Correct Texture Mapping(英語)</a></li>
  </ul>
  <li>Rendering To A Texture</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-render-to-texture.html">WebGL Render to Texture</a></li>
  </ul>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/ja/webgl-2d-drawimage.html">WebGL 2D - DrawImage(英語)</a>
      <li><a href="/webgl/lessons/ja/webgl-2d-matrix-stack.html">WebGL 2D - Matrix Stack(英語)</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/ja/webgl-text-html.html">WebGL Text - HTML(英語)</a>
      <li><a href="/webgl/lessons/ja/webgl-text-canvas2d.html">WebGL Text - Canvas 2D(英語)</a>
      <li><a href="/webgl/lessons/ja/webgl-text-texture.html">WebGL Text - Using a Texture(英語)</a>
      <li><a href="/webgl/lessons/ja/webgl-text-glyphs.html">WebGL Text - Using a Glyph Texture(英語)</a>
    </ul>
  </ul>
  <li>その他のトピック</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-setup-and-installation.html">WebGLの開発環境</a></li>
    <li><a href="/webgl/lessons/ja/webgl-boilerplate.html">WebGLのひな型コード</a></li>
    <li><a href="/webgl/lessons/ja/webgl-resizing-the-canvas.html">WebGLとcanvasのリサイズ</a></li>
    <li><a href="/webgl/lessons/ja/webgl-animation.html">WebGL - Animation(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-and-alpha.html">WebGL and Alpha(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-2d-vs-3d-library.html">WebGL - 2D vs 3D libraries(英語)</a></li>
    <li><a href="/webgl/lessons/ja/webgl-anti-patterns.html">WebGL - Anti-Patterns(英語)</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs(英語)</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



