<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ja/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Gregg Tavares. nor the names of his
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGLの基本" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="基本から最初のWebGLのレッソン" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/ja/webgl-fundamentals.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGLの基本" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/ja/webgl-fundamentals.html" />
<meta name="twitter:description" content="基本から最初のWebGLのレッソン" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGLの基本</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGLの基本</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>WebGLの基本</p>
<p>WebGLは三次元APIとして思われことも多い。
「WebGLを使えば簡単に三次元の映像を表示出来るでだろう」っと思ってしまう人も多い。
実はWebGLはただのピクセルを書くエンジンである。WebGLで自分の作成したコートで点、線、
三角形を使って色々なタスクを熟すことが出来る。
それ以上描きたければ点と線と三角形を使って自分のコードでWebGLを使うことが人用がある。</p>
<p>WebGLはコンピュータのGPUで動く。だからGPUで起動出来るコードを提供しなければいけない。
そのために２つの関数を提供必要がある。その関数は「頂点シェーダー」と「フラグメントシェーダー」と呼ばれ、
両方厳密なC/C++のような「GLSL」という言語で作成するものだ。その２つの組み合わせを「プログラム」という。</p>
<p>頂点シェーダーの役割は頂点の位置を計算すること。
その関数の導き出した頂点位置でWebGLは点と線と三角形を描く。
描いている最中フラグメントシェーダーを呼び出す。
フラグメントシェーダーの役割は描くピクセルごとに色の計算をすることである。</p>
<p>その２つの関数を起動する前にWebGL API経由でその関数の状況を指定する
ことが必要である。書きたい形ごとにWebGLの色々な状況を設定して、
そして<code>gl.drawArrays</code>か<code>gl.drawElements</code>の関数を呼び出したらGPUでシェーダーが起動する。</p>
<p>そのシェーダーの関数に提供したいデータはGPUにアップロードしなければいけない。
それは４つの方法がある。</p>
<ol>
<li><p>属性とバッファー</p>
<p>バッファーはGPUにあるバイナリデータの配列。中身は頂点の位置や、法線や、色や、
テクスチャーの座標などだが、好きなデータを入れること出来る。</p>
<p>属性はバッファーからデータを取ってシェーダーに提供する設定である。
例えばバッファーに位置ごとに三つの３２ビット数字が入ている。
ある属性の設定でどのバッファーから位置を取るかと、どのようなデータを取るか
（三つの３２ビット数字）とか、バッファーにそのデータは何処から始まるかとか、
一つの位置から次の位置になんバイト飛ぶかとかである。</p>
<p>バッファーは自由にデータを取ることが出来ない。
代わりに頂点シェーダーを呼び出す回数が設定して、
呼び出すごとに次のデータをバッファーから読んで属性にそのデータが入る。</p>
</li>
<li><p>ユニフォーム(uniform)</p>
<p>ユニフォームはシェーダーを起動する前に定義するシェーダーのグローバルの変数です。</p>
</li>
<li><p>テクスチャー</p>
<p>テクスチャーは自由にデータを読める配列です。
よくテくスチャーにイメージとか写真とかか絵のデータを入れるが、
テクスチャーはただのデータ配列なので色以外のデータを入れることも可能である。</p>
</li>
<li><p>ヴァリイング（varying)</p>
<p>ヴァリイングは頂点シェーダーからフラグメントシェーダーへデータを伝える方法です。
描画する形による（点、線、三角形）頂点シェーダーに定義します。
定義されたヴァリイングはフラグメントシェーダーが呼び出されている間補間される。</p>
</li>
</ol>
<p>WebGLの&quot;Hello World&quot;</p>
<p>WebGLは２つのことしか求めていない。それはクリップ空間と色である。
プログラマーの役目はその２つのことをWebGLに与えることである。
そのため２つのシェーダーを与える。頂点シェーダーでクリップ空間の頂点座標を与えて、
そしてフラグメントシェーダーで色を与える。</p>
<p>クリップ空間座標はキャンバスの要素（canvas)のサイズに関係がなく、いつも−１から＋１になる。
以下は一番単純なWebGLの例である。</p>
<p>まず頂点シェーダーで始まる。</p>
<pre><code>// バッファーからデータを取る属性
attribute vec4 a_position;

// 全てのシェーダーは「main」の関数がある
void main() {

  // 特別の変数「gl_Position」を割り当てることは頂点シェーダーの役割である
  gl_Position = a_position;
}
</code></pre><p>GLSLの代わりにJavaScriptで書かれて起動したらことように動く</p>
<pre><code>// *** 擬似コード!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // positionBufferから次の４つの数値をa_positionの属性に読み込み
     attributes.a_position = positionBuffer.slice((offset + i) * stide, size);

     runVertexShader();　// ⇐　頂点シェーダーを呼び出す！
     ...
     doSomethingWith_gl_Position();
}
</code></pre><p>実際GLSLのシェーダーでのデータは本物<code>positionBuffer</code>がバイナリに更新しなければならないので、
バッファーがらデータを取り込む際の計算方法は異なる。
でも、頂点シェーダーはこのような動くことと想像出来ると思う。</p>
<p>次はフラグメントシェーダーが必要</p>
<pre><code>// フラグメントシェーダーは既定の精度がないので選択することが必要である。
// 「mediump」は一般的な既定の設定である。それは「中間の精度」の意味である。
precision mediump float;

void main() {
  // 特別の変数「gl_FragColor」を割り当てることは
  // フラグメントシェーダーの役割である
  gl_FragColor = vec4(1, 0, 0.5, 1); // 赤紫
}
</code></pre><p>上記で<code>gl_FragColor</code>に<code>1,0,0,5,1</code>に割り当てる。それは赤＝１，緑＝０、青＝０．５、透明さ（アルファ）＝１。
WebGLの色は０〜１である。</p>
<p>２つのシェーダーを書いたのでWebGLを始めよう！</p>
<p>まずHTMLのCanvas要素が必要である</p>
<pre><code>&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre><p>それをJavaScriptで調べられる</p>
<pre><code>var canvas = document.getElementById(&quot;c&quot;);
</code></pre><p>それで<code>WebGLRenderingContext</code>を作成出来る</p>
<pre><code> var gl = canvas.getContext(&quot;webgl&quot;);
 if (!gl) {
    // no webgl for you!
    ...
</code></pre><p>そして先のシェーダーをコンパイルしてGPUにアップロードすることが必要なのでstringに入れることが必要である。
GLSLのstringをする方法はいくつかある。文字列の連結とか、AJAXでダウンロードすることとか、複数行テンプレートstringとか。
今回JavaScriptではない型付けされたscript要素に入れる方法をとる。</p>
<pre><code>&lt;script id=&quot;2d-vertex-shader&quot; type=&quot;notjs&quot;&gt;

  // バッファーからデータを取る属性
  attribute vec4 a_position;

  // 全てのシェーダーは「main」の関数がある
  void main() {

    // 特別の変数「gl_Position」を割り当てることは頂点シェーダーの役割である
    gl_Position = a_position;
  }

&lt;/script&gt;

&lt;script id=&quot;2d-fragment-shader&quot; type=&quot;notjs&quot;&gt;

  // フラグメントシェーダーは既定の精度がないので選択することが必要である。
  // 「mediump」は一般的な既定の設定である。それは「中間の精度」の意味である。
  precision mediump float;

  void main() {
    // 特別の変数「gl_FragColor」を割り当てることは
    // フラグメントシェーダーの役割である
    gl_FragColor = vec4(1, 0, 0.5, 1); // 赤紫
  }

&lt;/script&gt;
</code></pre><p>本格的な三次元のエンジンは色々な方法で動きながらコードを組み合わせてGLSLシェーダーを作成する。
しかし、このサイトであまり複雑なシェーダーを使わないので、動きながらシェーダー・コードを組み合わせて作成するのが必要ではない。</p>
<p>次にシェーダーを作成し、GLSLのコードをアップロードし、シェーダーをコンパイルする関数が必要である。</p>
<pre><code>function createShader(gl, type, source) {
  // シェーダーを作成
  var shader = gl.createShader(type);
  // GLSLのコードをGPUにアップロード
  gl.shaderSource(shader, source);
  // シェーダーをコンパイル
  gl.compileShader(shader);
  // 成功かどうかチェック
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader; // 成功。シェーダーを返す
  }

  // エラーを表示
  console.log(gl.getShaderInfoLog(shader));
  // シェーダーを削除
  gl.deleteShader(shader);
}
</code></pre><p>出来たら、その関数でシェーダー２つを作成出来る</p>
<pre><code>var vertexShaderSource = document.getElementById(&quot;2d-vertex-shader&quot;).text;
var fragmentShaderSource = document.getElementById(&quot;2d-fragment-shader&quot;).text;

var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre><p>それでその２つのシェーダーをプログラムにリンクする</p>
<pre><code>function createProgram(gl, vertexShader, fragmentShader) {
  // プログラムを作成
  var program = gl.createProgram();
  // プログラムに頂点シェーダーを付ける
  gl.attachShader(program, vertexShader);
  // プログラムにフラグメントシェーダーを付ける
  gl.attachShader(program, fragmentShader);
  // プログラムをリンクする
  gl.linkProgram(program);
  // 成功かどうかチェック
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;  // 成功。プログラムを返す
  }

  // エラーを表示
  console.log(gl.getProgramInfoLog(program));
  // プログラムを削除
  gl.deleteProgram(program);
}
</code></pre><p>それを呼び出す</p>
<pre><code>var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre><p>GLSLのプログラムを作成して、GPUにアップロードが出来たら、それにデータを与えることが必要である。
WebGL APIの役割のほとんどはGLSLプログラムにデータを与えることと動きの状況を設定することである。
今回のGLSLプログラムのインプットは<code>a_position</code>の属性しかない。
作成したプログラムに最初するべきことは属性のローケーションを調べることである</p>
<pre><code>var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre><p>属性のローケーションを調べるのは描画する時ではなく、プログラムを最初に起動する時に行った方がいい。</p>
<p>属性はバッファーからデータを取るので、バッファーを作成しなければならない。</p>
<pre><code>var positionBuffer = gl.createBuffer();
</code></pre><p>WebGLのレソース（資源）を操るためグローバル結び点（bind point)に結び付けることが必要である。
結び点はWebGLの中のグローバル変数のようなものである。リソースを結び点に結びつけたら、その後
結び点でリソースを操る。さて、<code>positionBuffer</code>を結びつけよう。</p>
<pre><code>gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre><p>そして、<code>ARRAY_BUFFER</code>という結び点を参照して、データをバッファーに入れる。</p>
<pre><code>// 三点の二次元頂点
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>ここで色々なことを行われている。まず<code>positions</code>というJavaScriptの配列がある。WebGLは強く
定型化されたデータが要るので、 <code>new Float32Array(positions)</code>の部分は32ビット数値配列を
作成して、それに<code>positions</code>の内容をコピーする。それで<code>gl.bufferData</code>はそのデータをGPUに
ある<code>positionBuffer</code>にアップロードする。<code>positionBuffer</code>が<code>ARRAY_BUFFER</code>に結び付いている
ので<code>positionBuffer</code>はコピーの目標になっている。</p>
<p><code>gl.bufferData</code>の最後の引数、<code>gl.STATIC_DRAW</code>はWebGLにそのデータがどのように使うのかという
ヒントである。<code>gl.STATIC_DRAW</code>の意味はこのデータは更新しないヒントである。</p>
<p>今までのコードが初期化のコードである。ウエブページをロードしてから起動させる。
下記のコードは描画するコードである。描画してほしい時に呼び出すゴードである。</p>
<h2 id="-">描画</h2>
<p>描画する前にキャンバスを表示されているサイズと同じサイズにした方がいい。キャンバスは
2つのサイズがある。一つは内容の解像度で、それがキャンバスサイズである。それに表示のサイズもあり、
これはCSSで決定されている。他の方法より柔軟なのでキャンバスのサイズをCSSで設定した方がいい。</p>
<p>キャンバスの解像度を表示されているサイズと同じにするため
<a href="webgl-resizing-the-canvas.html">ここで説明しれているヘルパー関数を利用している</a>。</p>
<p>ここにあるサンプルでは自分のウインドウで起動する場合、キャンバスのサイズは400x300になるが、
iframeの中で起動する場合iframeのサイズに合わせられる。CSSで決定しているのでどちらにも対処出来る。</p>
<pre><code>webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre><p>クリプ空間頂点を割り当たってられた<code>gl_Position</code>はピクセル（顔面空間）に変換の決定する必要である。
そのためキャンバスのサイズを<code>gl.viewport</code>に渡す。</p>
<pre><code>gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre><p>これは−1〜+１のクリプ空間からｘ軸のために0〜<code>gl.canvas.width</code>とy軸のために0〜<code>gl.canvas.height</code>をWebGLに設定するものである。</p>
<p>キャンバスをキリアする。<code>0,0,0,0</code>は赤、緑、青、あるファ（透明さ）なので今回
キャンバスを透明にキリアする。</p>
<pre><code>// キャンバスをクリアする
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre><p>WebGLにどのシェーダー・プログラムを起動してほしいが教える。</p>
<pre><code>// 作成したプログラム（シェーダー2つ）を設定する
gl.useProgram(program);
</code></pre><p>次にWebGLにどうやってデータを上記で作ったバッファーからシェーダーの属性に読み込むかを教えることが必要である。
まず属性オンにする。</p>
<pre><code>gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre><p>そしてデータの取り方を設定する。</p>
<pre><code>// positionBufferをARRAY_BUFFERに結び付ける
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// 属性にどうやってpositionBuffer（ARRAY_BUFFER)からデータを取りか。
var size = 2;          // 呼び出すごとに2つの数値
var type = gl.FLOAT;   // データは32ビットの数値
var normalize = false; // データをnormalizeしない
var stride = 0;        // シェーダーを呼び出すごとに進む距離
                       // 0 = size * sizeof(type)
var offset = 0;        // バッファーの頭から取り始める
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre><p><code>gl.vertexAttribPointer</code>の隠れている点が<code>ARRAY_BUFFER</code>に結び付いているバッファーを属性にも
むす付ける。つまり<code>positionBuffer</code>はこの属性に結び付く。<code>ARRAY_BUFFER</code>に他のバッファーを
結び付けても、属性はまだ<code>positionBuffer</code>に結び付いている。</p>
<p>GLSLの頂点シェーダーの立場から<code>a_position</code>は<code>vec4</code>である。</p>
<pre><code>attribute vec4 a_position;
</code></pre><p><code>vec4</code>は４つの値がある。JavaScriptで<code>a_position = {x: 0, y: 0, z: 0, w: 0}</code>に近い形になる。
上記で<code>size = 2</code>のした。属性の規定値は<code>0,0,0,1</code>なので、この属性の最初の2つの値（xとy）はバッファーから取る。
zとwは既定値の0、1になる。</p>
<p>上記の全ての後やっとWebGLにシェーダーを起動することを頼める。</p>
<pre><code>var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p><code>count</code>は３になっているので頂点シェーダーは三回呼び出される。初回頂点シェーダーの属性の
<code>a_position.x</code>と<code>a_position.y</code>は<code>positionBuffer</code>の最初の2つの値になる。二回目、<code>a_position.xy</code>は
二番目の2つの値になる。最後は三回目の2つの値になる。</p>
<p><code>primitiveType</code>は<code>gl.TRIANGLES</code>にしたので,頂点シェーダーは三回ごとに呼び出されたら、
WebGLは<code>gl_Position</code>に割り当てられた３つの値で三角形を描画する。キャンバスがどんなサイズに
なってもその値は-1~+1クリプ空間座標である。</p>
<p>この頂点シェーダーは、ただ<code>positionBuffer</code>の値を<code>gl_Position</code>にコピーしているので、このクリプ空間座標に三角形を描画する。</p>
<pre><code>  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre><p>キャンバスのサイズが400x300のピクセルならWebGLはこのように頂点のクリプ空間から画面空間に変化する。</p>
<pre><code> クリプ空間          画面空間
   0, 0       -&gt;   200, 150
   0, 0.5     -&gt;   200, 225
 0.7, 0       -&gt;   340, 150
</code></pre><p>その座標でWebGLは三角形を描画する。ピクセルごとにフラグメントシェーダーを呼び出す。
フラグメントシェーダーはだた<code>gl_FragColor</code>を<code>1, 0, 0.5, 1</code>とする。キャンバスの色の部分ごとに
8ビットなので、WebGLは<code>255,0,127,255</code>をキャンバスに書き込む。</p>
<p>これはライブサンプルである。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/../webgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">ここにクリックして別のウインドウを開く</a>
</div>

</p>
<p>上の場合にはこの頂点シェーダーは頂点の位置データ直接渡すでけである。その位置はもう
クリプ空間になっているので、何もしていない。<em>三次元の絵を描画してければ自分自身で
三次元データからクリプ空間に変化するシェーダーを作成しなければならない。WebGLはただの描画するAPIだから</em>。</p>
<p>三角形がなぜ真ん中から右上に位置するのかな〜人もいると思うので、説明しよう。クリプ空間
でX軸は-1〜+1である。だから０は真ん中で正の値はその右になる。
上の方に位置する理由はクリプ空間のY軸が-1＝底で、+1＝頂なので、0＝真ん中で正の値は
その上になるからである。</p>
<p>2次元のものならクリプ空間よりよく使われているピクセル空間の方が楽なので、<code>position</code>の座標を
ピクセルで与える為に、シェーダーの計算し方をピクセル座標からクリプ空間に変更しよう。
これは変更されたシェーダー：</p>
<pre><code>&lt;script id=&quot;2d-vertex-shader&quot; type=&quot;notjs&quot;&gt;

-  attribute vec4 a_position;
*  attribute vec2 a_position;

+  uniform vec2 u_resolution;  // キャンバスの解像度

  void main() {
+    // positionはピクセルから0〜1に
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // 0〜1から0〜2に
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // 0〜2から-1〜+1に(クリプ空間）
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }

&lt;/script&gt;
</code></pre><p>この変更に関して留意したい点：</p>
<ul>
<li><p><code>x</code>と<code>y</code>しか使ってないので<code>a_position</code>を<code>vec2</code>にした。 <code>vec2</code>は<code>vec4</code>に似てるがxとyしかない。</p>
</li>
<li><p><code>u_resolution</code>というユニフォームを追加した。ユニフォームを設定するためにその位置を調べることが必要である。</p>
<pre><code>var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre></li>
</ul>
<p>それ以外は上記のコメントでこ理解頂けるだろう。<code>u_resolution</code>をキャンバスの解像度に設定すれてば、
この頂点シェーダーが<code>positionBuffer</code>に入っているピクセル座標をクリプ空間に計算する。</p>
<p>それだこの座標はクリプ空間からピクセルに変更出来る。今回3つの頂点で出来ている三角形2つで四角形を描画する。</p>
<pre><code>var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>どこプログラムを利用するかを定義してから、ユニフォームの値を設定出来る。<code>gl.useProgram</code>は上記の<code>gl.bindBuffer</code>
と同じように、どのシェーダー・プログラムを使うかを定義する。その後<code>gl.uniform〜</code>の関数の全ては現行のプログラムの
ユニフォームを設定出来る。</p>
<pre><code>gl.useProgram(program);

...

// resolutionを設定する
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre><p>そして勿論２つの三角形を描画するため、先ほど頂点シェーダーを6回呼び出すことが必要なので<code>count</code>は
<code>6</code>にする。</p>
<pre><code>// 描画する
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>そしてこのようになる。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/../webgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">ここにクリックして別のウインドウを開く</a>
</div>

</p>
<p>Note: このサンプルとその後の全てのサンプルは、シェーダーのコンパイルとリンクの為の関数を
含んでいる<a href="webgl-boilerplate.html"><code>webgl-utils.js</code>](/webgl/resources/webgl-utils.js)というライブラリを使っている。
サンプルを混乱させたくないので、［ポイラプレート・コード・ライブラリ</a>にした。</p>
<p>また目立つのはこの四角形は下の方に位置していることだろう。WebGLは0,0を左下とみなしている。
2次元APIの0,0は一般的な左下にしたければクリプ空間のｙ座標を弾く</p>
<pre><code>*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre><p>それで四角形は期待通りになる。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/../webgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">ここにクリックして別のウインドウを開く</a>
</div>

</p>
<p>四角形を定義している部分をサイズが設定出来る関数にしよう。更に、描く色も設定出来る
ようにする。</p>
<p>まずフラグメントシェーダーを、色ユニフォームが使えるようにする。</p>
<pre><code>&lt;script id=&quot;2d-fragment-shader&quot; type=&quot;notjs&quot;&gt;
  precision mediump float;

+  uniform vec4 u_color;

  void main() {
*    gl_FragColor = u_color;
  }
&lt;/script&gt;
</code></pre><p>そして、次にあるのは50個の四角形をランダムなサイズとランダムな色で描画するコードである。</p>
<pre><code>  var colorUniformLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // 50個のランダム四角形のランダム色で描画する
  for (var ii = 0; ii &lt; 50; ++ii) {
    // ランダム四角形の設定する
    // 最後にARRAY_BUFFERの結び点に結び付いたバッファーはpositionBufferだから
    // positionBufferにアップロードすることになる。
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // ランダムな色を設定する
    gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);

    // 四角形をっ描画する
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
}

// 0〜(range - 1)を作成
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// バッファーに四角形の頂点を入れる

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...)は`ARRAY_BUFFER`の結び点に
  // 結び付いているバッファーにアップロードする。今まで一つのバッファーしかないけど、
  // 2つ以上あればgl.bufferDataを呼び出す前に変更したいバッファーをARRAY_BUFFERに
  // 結び付けることが必要である。

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre><p>それでこれは50個の四角形である。</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/../webgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">ここにクリックして別のウインドウを開く</a>
</div>

</p>
<p>気が付いて欲しい点はWebGLが結構単純なAPIということである。
まあ、ここまでの流れは「単純」とは言えないが、WebGLがやっていること自体は単純なことである。
ただプログラマーが書いた２つの関数（頂点シェーダーとフラグメントシェーダー）で三角形、線、
点を描画する。三次元の為に複雑になるかもしれないが、その場合複雑なシェーダーはプログラマーに追加される。
WebGLはただ単純な描画をするAPIである。</p>
<p>今回のサンプルでは1つの属性と2つのユニフォームでデータを提供した。
一般的には複数の属性と多くのユニフォームを使う。この記事の上の方で<em>ヴァリイング</em>と<em>テクスチャー</em>を紹介した。
それらについていずれ説明しよう。</p>
<p>次に行く前に言っていおいた方がいい点は、このサンプルの<code>setRectangle</code>のようにバッファーのデータを更新することは一般的ではない。
しかし、GLSLならちょっとだけ数学を使えば出来ることと、データはピクセル座標で提供することで、
簡単に説明出来ると思った。それは駄目な方法ではない。あるケースでこの方法が適切であるからだか、
<a href="webgl-2d-translation.html">ズカの形状を移動、回転、拡大、縮小、一般適な方法はこちらを御覧ください</a>。</p>
<p>ウェブページの制作経験があまりなければ（あっても）<a href="webgl-setup-and-installation">インストールとセット・アップの記事</a>をチェックして、WebGLの開発の秘訣を参照して下さい。</p>
<p>WebGLの知識が全くなくて、GLSLとかシェーダーとか、GPUが何をするものなどか知らなければ<a href="webgl-how-it-works.html">WebGLの基本的な動き方</a>をチェックしてください。</p>
<p>サンプルが使っている<a href="webgl-boilerplate.html">ボイラプレート・コード・ライブラリについて]</a>をざっと読んだ方がいい。
このサイトに載せてあるサンプルはほとんど一つの形状しか描画してないから、通常のWebGLアプリの構造を理解する為に<a href="webgl-drawing-multiple-things.html">複数のものを描画する方法の記事</a>
もざっと目を透した方がいい。</p>
<p>いずれにしても,ここから2つの方向がある。画像処理に興味があれば<a href="webgl-image-processing.html">二次元画像処理のし方</a>を見て下さい。移動、回転、拡大／縮小、そして3次元のことに興味があれば<a href="webgl-2d-translation.html">ここで始めよう</a>。</p>
<div class="webgl_bottombar">
<h3>type=”notjs”はどいう意味？</h3>
<p>
<code>&lt;script&gt;</code>タグの内容は通常JavaScriptである。<code>type</code>は無しとか、<code>type=”javascript”</code>とか、<code>type=”text/javascript”<code>にしたら、ブラウザがタグ内容をJavaScriptとして解析する。それ以外にしたらブラウザがタグの内容を無視する。つまり<code>type=”notjs”</code>とか、<code>type=”foobar”</code>などはブラウザに意味がない。だからシェーダーのコードscriptタグに入れて簡単に編集が出来るようになる。
</p>
<p>
ストリングを連結する方法もある
</p>
<pre class="prettyprint">
  var shaderSource =
    "void main() {\n" +
    "  gl_FragColor = vec4(1,0,0,1);\n" +
    "}";
</pre>
<p>
AJAXでダウンロードする方法もあるが、これは遅くて非同期になる。
</p>
<p>
最近出た新たな方法は複数行のテンプレートを使うこと
</p>
<pre class="prettyprint">
  var shaderSource = `
    void main() {
      gl_FragColor = vec4(1,0,0,1);
    }
  `;
</pre>
<p>
複数行のテンプレートはWebGLに対応しているブラウザなら全てオッケーである。古いブラウザでは対応してないのでそれにサポートしたければ、
複数行テンプレートを利用しないことにするか、それとも<a href="https://babeljs.io/">トランズパイラー</a>を使うことにしたらいい。
</p>
</div>

      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>質問? <a href="http://stackoverflow.com/questions/tagged/webgl">stackoverflowで(英語)</a>.</div>
        <div>問題/バッグ? <a href="http://github.com/greggman/webgl-fundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGLの基本';
            var disqus_title = 'WebGLの基本';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>基本</li>
  <ul>
    <li><a href="/webgl/lessons/ja/webgl-fundamentals.html">WebGLの基本</a></li>
    <li><a href="/webgl/lessons/webgl-how-it-works.html">WebGL How It Works(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">WebGL Shaders and GLSL(英語)</a></li>
  </ul>
  <li>Image Processing</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-image-processing.html">WebGL Image Processing(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-image-processing-continued.html">WebGL Image Processing Continued(英語)</a></li>
  </ul>
  <li>2D translation, rotation, scale, matrix math</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-2d-translation.html">WebGL 2D Translation(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-2d-rotation.html">WebGL 2D Rotation(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-2d-scale.html">WebGL 2D Scale(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-2d-matrices.html">WebGL 2D Matrices(英語)</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-orthographic.html">WebGL - Orthographic 3D(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL 3D Perspective(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-3d-camera.html">WebGL 3D - Cameras(英語)</a></li>
  </ul>
  <li>Lighting</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">WebGL 3D - Directional Lighting(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-point.html">WebGL 3D - Point Lighting(英語)</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">WebGL - Less Code, More Fun(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">WebGL - Drawing Multiple Things(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-scene-graph.html">WebGL - Scene Graphs(英語)</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-textures.html">WebGL 3D - Textures(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-2-textures.html">WebGL - Using 2 or More Textures(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-cors-permission.html">WebGL - Cross Origin Images(英語)</a></li>
  </ul>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-2d-drawimage.html">WebGL 2D - DrawImage(英語)</a>
      <li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">WebGL 2D - Matrix Stack(英語)</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-text-html.html">WebGL Text - HTML(英語)</a>
      <li><a href="/webgl/lessons/webgl-text-canvas2d.html">WebGL Text - Canvas 2D(英語)</a>
      <li><a href="/webgl/lessons/webgl-text-texture.html">WebGL Text - Using a Texture(英語)</a>
      <li><a href="/webgl/lessons/webgl-text-glyphs.html">WebGL Text - Using a Glyph Texture(英語)</a>
    </ul>
  </ul>
  <li>Misc</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-setup-and-installation.html">WebGL Setup And Installation(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-boilerplate.html">WebGL Boilerplate(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">WebGL Resizing the Canvas(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-animation.html">WebGL - Animation(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">WebGL - 2D vs 3D libraries(英語)</a></li>
    <li><a href="/webgl/lessons/webgl-anti-patterns.html">WebGL - Anti-Patterns(英語)</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs(英語)</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



