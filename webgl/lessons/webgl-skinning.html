<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-skinning.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL Skinning" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="How to skin a mesh in WebGL" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/webgl-skinning.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL Skinning" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/webgl-skinning.html" />
<meta name="twitter:description" content="How to skin a mesh in WebGL" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL Skinning</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-skinning.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-skinning.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-skinning.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Skinning</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Skinning in graphics is the name given to moving a set of vertices based
on the weighted influence of multiple matrices. That&#39;s pretty abstract.</p>
<p>It&#39;s called <em>skinning</em> because it&#39;s typically used to make 3D characters
have a &quot;skeleton&quot; made from &quot;bones&quot; where &quot;bone&quot; is another name for matrix
and then <strong>per vertex</strong> setting the influence of each bone to that vertex.</p>
<p>So for example the hand bone would have nearly 100% influence on the vertices
near the hand of a character where as the foot bone would have zero influence
on those same vertices.</p>
<p>The basic part is that you need bones (which is just a fancy way of saying
a matrix hierarchy) and weights.  Weights are per vertex values that go
from 0 to 1 to say how much a particular bone-matrix affects the position
of that vertex.  Weights are kind of like vertex colors as far as data.
One set of weights per vertex.  In other words the weights are put in a
buffer and provided through attributes.</p>
<p>Typically you limit the number of weights per vertex partly because
otherwise it would be way too much data.  A character can have anywhere
from 15 bones (Virtua Fighter 1) to 150-300 bones (some modern games).
If you had 300 bones you&#39;d need 300 weights PER vertex PER bone.  If your
character had 10000 vertices that would be 3 million weights needed.</p>
<p>So, instead most realtime skinning systems limit it ~4 weights per vertex.
Usually this is accomplished in an exporter/converter that takes data from
a 3D packages like blender/maya/3dsmax and for each vertex finds the 4
bones with the highest weights and then normalizing those weights</p>
<p>To give an pseudo example a non-skinned vertex is typically computed like this</p>
<pre><code>gl_Position = projection * view * model * position;
</code></pre><p>A skinned vertex is effectively computed like this</p>
<pre><code>gl_Position = projection * view *
              (bone1Matrix * position * weight1 +
               bone2Matrix * position * weight2 +
               bone3Matrix * position * weight3 +
               bone4Matrix * position * weight4);
</code></pre><p>Assuming you stored the bones matrices in a uniform array, and you
passed in the the weights and which bone each weight applies to as
attributes you might do something like</p>
<pre><code>attribute vec4 a_position;
attribute vec4 a_weights;         // 4 weights per vertex
attribute vec4 a_boneNdx;         // 4 bone indices per vertex
uniform mat4 bones[MAX_BONES];    // 1 matrix per bone

gl_Position = projection * view *
              (a_bones[int(a_boneNdx[0])] * a_position * a_weight[0] +
               a_bones[int(a_boneNdx[1])] * a_position * a_weight[1] +
               a_bones[int(a_boneNdx[2])] * a_position * a_weight[2] +
               a_boneS[int(a_boneNdx[3])] * a_position * a_weight[3]);
</code></pre><p>There&#39;s one more issue.  Let&#39;s say you have a model of a person with
the origin (0,0,0) on the floor just between their feet.</p>
<div class="webgl_center"><img src="resources/bone-head.svg" style="width: 500px;"></div>

<p>Now imagine you put a matrix/bone/joint at their head and you want to use
that for bone for skinning.  To keep it simple imagine you just set the
weights so the the vertices of the head have a weight of 1.0 for the head
bone and no other joints influence those vertices.  </p>
<div class="webgl_center"><img src="resources/bone-head-setup.svg" style="width: 500px;"></div>

<p>There&#39;s a problem.
The head vertices are 2 units above the origin.  The head bone is also 2
units above the origin.  If you actually multiplied those head vertices by
the head bone matrix you&#39;d get vertices 4 units above the origin.  The
original 2 units of the vertices + the 2 units of the head bone matrix.</p>
<div class="webgl_center"><img src="resources/bone-head-problem.svg" style="width: 500px;"></div>

<p>A solution is to store a &quot;bind pose&quot; which is an extra matrix per joint of
where each matrix was before you used it to influence the vertices.  In that
case the bind pose of the head matrix would be 2 units above the origin.
So now you can use the inverse of that matrix to subtract out the extra 2
units.</p>
<p>In other words the bone matrices passed to the shader have each been
multiplied by their inverse bind pose so as to make their influence only
how much they changed from their original positions relative to the origin
of the mesh.</p>
<p>Let&#39;s make a small example. We&#39;ll animate in 2d a grid like this</p>
<div class="webgl_center"><img src="resources/skinned-mesh.svg" style="width: 400px;"></div>

<ul>
<li>Where <code>b0</code>, <code>b1</code>, and <code>b2</code> are the bone matrices.</li>
<li><code>b1</code> is a child of <code>b0</code> and <code>b2</code> is a child of <code>b1</code></li>
<li>Verts <code>0,1</code> will get a weight of 1.0 from bone b0</li>
<li>Verts <code>2,3</code> will get a weight of 0.5 from bones b0 and b1</li>
<li>Verts <code>4,5</code> will get a weight of 1.0 from bone b1</li>
<li>Verts <code>6,7</code> will get a weight of 0.5 from bones b1 and b2</li>
<li>Verts <code>8,9</code> will get a weight of 1.0 from bone b3</li>
</ul>
<p>We&#39;ll use the utils described in <a href="webgl-less-code-more-fun.html">less code more fun</a>.</p>
<p>First we need the vertices and for each vertex the index
of each bone that influences it and a number from 0 to 1
of how much influence that bone has.</p>
<pre><code>var arrays = {
  position: {
    numComponents: 2,
    data: [
     0,  1,  // 0
     0, -1,  // 1
     2,  1,  // 2
     2, -1,  // 3
     4,  1,  // 4
     4, -1,  // 5
     6,  1,  // 6
     6, -1,  // 7
     8,  1,  // 8
     8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: [
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ],
  },
  weight: {
    numComponents: 4,
    data: [
     1, 0, 0, 0,  // 0
     1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
     1, 0, 0, 0,  // 4
     1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
     1, 0, 0, 0,  // 8
     1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// calls gl.createBuffer, gl.bindBuffer, gl.bufferData
var bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);
</code></pre><p>We can define our uniform values including a matrix for each bone</p>
<pre><code>// 4 matrices, one for each bone
var numBones = 4;
var boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
};
</code></pre><p>We can make views into the boneArray, one for each matrix</p>
<pre><code>// make views for each bone. This lets all the bones
// exist in 1 array for uploading but as separate
// arrays for using with the math functions
var boneMatrices = [];  // the uniform data
var bones = [];         // the value before multiplying by inverse bind matrix
var bindPose = [];      // the bind matrix
for (var i = 0; i &lt; numBones; ++i) {
  boneMatrices.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
  bindPose.push(m4.identity());  // just allocate storage
  bones.push(m4.identity());     // just allocate storage
}
</code></pre><p>And then some code to manipulate the bone matrixes. We&#39;ll just rotate
them in a heirarchy like the bones of a finger.</p>
<pre><code>// rotate each bone by angle and simulate a hierarchy
function computeBoneMatrices(bones, angle) {
  var m = m4.identity();
  m4.zRotate(m, angle, bones[0]);
  m4.translate(bones[0], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[1]);
  m4.translate(bones[1], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[2]);
  // bones[3] is not used
}
</code></pre><p>Now call it once to generate their initial positions and use the result
to compute the inverse bind pose matrices.</p>
<pre><code>// compute the initial positions of each matrix
computeBoneMatrices(bindPose, 0);

// compute their inverses
var bindPoseInv = bindPose.map(function(m) {
  return m4.inverse(m);
});
</code></pre><p>Now we&#39;re ready to render</p>
<p>First we animate the bones, conmputing a new world matrix for each</p>
<pre><code>var t = time * 0.001;
var angle = Math.sin(t) * 0.8;
computeBoneMatrices(bones, angle);
</code></pre><p>Then we multiple the result of each by the inverse bind pose to deal with
the issue mentioned above</p>
<pre><code>// multiply each by its bindPoseInverse
bones.forEach(function(bone, ndx) {
  m4.multiply(bone, bindPoseInv[ndx], boneMatrices[ndx]);
});
</code></pre><p>Then all the normal stuff, setting up the attributes, setting the uniforms, and drawing.</p>
<pre><code>gl.useProgram(programInfo.program);
// calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

// calls gl.uniformXXX, gl.activeTexture, gl.bindTexture
webglUtils.setUniforms(programInfo, uniforms);

// calls gl.drawArrays or gl.drawIndices
webglUtils.drawBufferInfo(gl, bufferInfo, gl.LINES);
</code></pre><p>And here&#39;s the result</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>The red lines are the <em>skinned</em> mesh.  The green and blue lines represent
the x-axis and y-axis of each bone or &quot;joint&quot;. You can see how the vertices
that are influenced by multiple bones move between the bones that influence
them. We didn&#39;t cover how the bones are drawn as it&#39;s not important to
explaining how skinning works. See the code if you&#39;re curious.</p>
<p>NOTE: bones vs joints is confusing. There&#39;s only 1 thing, <em>matrices</em>.
But, in a 3d modelling package they usually draw a gizmo (a ui widget)
between each matrix. That looks ends up looking like a bone. The joints
are where matrices are and they draw a line or cone from each joint
to the next to make it kind of look like a skeleton.</p>
<div class="webgl_center">
  <img src="resources/bone-display.png" style="width: 351px;">
  <div class="caption"><a href="https://www.blendswap.com/blends/view/66412">LowPoly Man</a> by <a href="https://www.blendswap.com/user/TiZeta">TiZeta</a></div>
</div>

<p>Another minor thing to note, the example above is using floats for the weights
and the bone indices but you could easily use <code>UNSIGNED_BYTE</code> to save a
bunch of space.</p>
<p>Unfortunately there&#39;s a limit to the number of uniforms you can use in a shader.
The lower limit on WebGL is 64 vec4s which is only 8 mat4s and you probably
need some of those uniforms for other things like for example we have <code>color</code>
in the fragment shader and we have <code>projection</code> and <code>view</code> which means if
we were on a device with a limit of 64 vec4s we could only have 5 bones! Checking
<a href="https://webglstats.com/webgl/parameter/MAX_VERTEX_UNIFORM_VECTORS">WebGLStats</a>
most devices support 128 vec4s and 70% of them support 256 vec4s but with
are sample above that&#39;s still only 13 bones and 29 bones respectively. 13 is
not even enough for a early 90s Virtua Fighter 1 style character and 29 is not
close to the number used in most modern games.</p>
<p>A couple ways around that. One is to pre-process the models offline and break them
into multiple parts each one using no more than N bones. That&#39;s pretty complicated
and brings it&#39;s own set of issues.</p>
<p>Another is to store the bone matrices in a texture. This is an important reminder
that textures are not just images, they are effectively 2D arrays of random access
data that you can pass to a shader and you can use them for all kinds of things
that are not just reading images for texturing.</p>
<p>Let&#39;s pass our matrices in a texture to bypass the uniform limit. To make this
easy we&#39;re going to use floating point textures. Floating point textures are
an optional feature of WebGL but fortunately they are supported by most devices.</p>
<p>Here&#39;s the code to get the extension. If it fails we&#39;d probably want to either tell
the user they are out of luck or choose some other solution.</p>
<pre><code>var ext = gl.getExtension(&#39;OES_texture_float&#39;);
if (!ext) {
  return;  // the extension doesn&#39;t exist on this device
}
</code></pre><p>Let&#39;s update the shader to get the matrices out of a texture.
We&#39;ll make the texture have one matrix per row. Each texel of the texture
has R, G, B, and A, that&#39;s 4 values so we only need 4 pixels per matrix,
one pixel for each row of the matrix.
Textures can usually be at least 2048 pixels in certain dimension so
this will give us room for at least 2048 bone matrices which is plenty.</p>
<pre><code>attribute vec4 a_position;
attribute vec4 a_weight;
attribute vec4 a_boneNdx;

uniform mat4 projection;
uniform mat4 view;
*uniform sampler2D boneMatrixTexture;
*uniform float numBones;

+// these offsets assume the texture is 4 pixels across
+#define ROW0_U ((0.5 + 0.0) / 4.)
+#define ROW1_U ((0.5 + 1.0) / 4.)
+#define ROW2_U ((0.5 + 2.0) / 4.)
+#define ROW3_U ((0.5 + 3.0) / 4.)
+
+mat4 getBoneMatrix(float boneNdx) {
+  float v = (boneNdx + 0.5) / numBones;
+  return mat4(
+    texture2D(boneMatrixTexture, vec2(ROW0_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW1_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW2_U, v)),
+    texture2D(boneMatrixTexture, vec2(ROW3_U, v)));
+}

void main() {

  gl_Position = projection * view *
*                (getBoneMatrix(a_boneNdx[0]) * a_position * a_weight[0] +
*                 getBoneMatrix(a_boneNdx[1]) * a_position * a_weight[1] +
*                 getBoneMatrix(a_boneNdx[2]) * a_position * a_weight[2] +
*                 getBoneMatrix(a_boneNdx[3]) * a_position * a_weight[3]);

}
</code></pre><p>One thing to note is the texture coordinates for the pixels in a texture or texels are
computed from their edges. As we went over in <a href="webgl-3d-textures.html">the article on textures</a>
texture coordinates go from 0 to 1 across the texture. It turns out 0 is the left edge of the left most
pixel and 1 is the right edge of the right most pixel. If you had a 3 pixel wide texture then
it would be like this.</p>
<div class="webgl_center"><img src="resources/texel-coords.svg" style="width: 400px;"></div>

<p>If you want to look up a specific pixel then the formula is</p>
<pre><code> (x + .5) / width
</code></pre><p>Above you&#39;ll see for each pixel that&#39;s</p>
<pre><code> (0 + .5) / 3  = 0.166
 (1 + .5) / 3 =  0.5
 (2 + .5) / 3 =  0.833
</code></pre><p>or</p>
<div class="webgl_center"><img src="resources/texel-coords-middle.svg" style="width: 400px;"></div>

<p>Now we&#39;ll setup a texture we can put the bone matrices in</p>
<pre><code>// prepare the texture for bone matrices
var boneMatrixTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
// since we want to use the texture for pure data we turn
// off filtering
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
// also turn off wrapping since the texture might not be a power of 2
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>And we&#39;ll pass that texture and number of bones in as uniforms</p>
<pre><code>var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
*  boneMatrixTexture,
*  numBones,
  color: [1, 0, 0, 1],
};
</code></pre><p>Then the only thing we need to change is to update the texture with the
latest bone matrices when rendering</p>
<pre><code>// update the texture with the current matrices
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,         // level
    gl.RGBA,   // internal format
    4,         // width 4 pixels, each pixel has RGBA so 4 pixels is 16 values
    numBones,  // one row per bone
    0,         // border
    gl.RGBA,   // format
    gl.FLOAT,  // type
    boneArray);
</code></pre><p>The result it the same but we&#39;ve solved the issue that there aren&#39;t
enough uniforms to pass in the matrices via uniforms.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-bone-matrices-in-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-bone-matrices-in-texture.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>So that&#39;s the basics of skinning. It&#39;s not so hard to write the code to display
a skinned mesh. The harder part is actually getting data. You generally need
some 3D software like blender/maya/3d studio max, and then to either write
your own exporter or find a an exporter and format that will provide all the data needed.
The vertices, their bones, which bones influence which vertices and their influence
weights,</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/fr/webgl-skinning.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-skinning.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-skinning.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-skinning.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-skinning.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>
  <li>Fundamentals</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-fundamentals.html">WebGL Fundamentals</a></li>
    <li><a href="/webgl/lessons/webgl-how-it-works.html">WebGL How It Works</a></li>
    <li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">WebGL Shaders and GLSL</a></li>
  </ul>
  <li>Image Processing</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-image-processing.html">WebGL Image Processing</a></li>
    <li><a href="/webgl/lessons/webgl-image-processing-continued.html">WebGL Image Processing Continued</a></li>
  </ul>
  <li>2D translation, rotation, scale, matrix math</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-2d-translation.html">WebGL 2D Translation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-rotation.html">WebGL 2D Rotation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-scale.html">WebGL 2D Scale</a></li>
    <li><a href="/webgl/lessons/webgl-2d-matrices.html">WebGL 2D Matrices</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-orthographic.html">WebGL - Orthographic 3D</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL 3D Perspective</a></li>
    <li><a href="/webgl/lessons/webgl-3d-camera.html">WebGL 3D - Cameras</a></li>
  </ul>
  <li>Lighting</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">WebGL 3D - Directional Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-point.html">WebGL 3D - Point Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">WebGL 3D - Spot Lighting</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">WebGL - Less Code, More Fun</a></li>
    <li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">WebGL - Drawing Multiple Things</a></li>
    <li><a href="/webgl/lessons/webgl-scene-graph.html">WebGL - Scene Graphs</a></li>
  </ul>
  <li>Geometry</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">WebGL 3D Geometry - Lathe</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-textures.html">WebGL 3D - Textures</a></li>
    <li><a href="/webgl/lessons/webgl-data-textures.html">WebGL Data Textures</a></li>
    <li><a href="/webgl/lessons/webgl-2-textures.html">WebGL - Using 2 or More Textures</a></li>
    <li><a href="/webgl/lessons/webgl-cors-permission.html">WebGL - Cross Origin Images</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Perspective Correct Texture Mapping</a></li>
  </ul>
  <li>Rendering To A Texture</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-render-to-texture.html">WebGL Render to Texture</a></li>
  </ul>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a>
      <li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">WebGL 2D - Matrix Stack</a>
    </ul>
    <li>3D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-cube-maps.html">WebGL - Cubemaps</a></li>
      <li><a href="/webgl/lessons/webgl-environment-maps.html">WebGL - Environment maps</a></li>
      <li><a href="/webgl/lessons/webgl-skybox.html">WebGL - Skyboxes</a></li>
      <li><a href="/webgl/lessons/webgl-skinning.html">WebGL - Skinning</a></li>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-text-html.html">WebGL Text - HTML</a></li>
      <li><a href="/webgl/lessons/webgl-text-canvas2d.html">WebGL Text - Canvas 2D</a></li>
      <li><a href="/webgl/lessons/webgl-text-texture.html">WebGL Text - Using a Texture</a></li>
      <li><a href="/webgl/lessons/webgl-text-glyphs.html">WebGL Text - Using a Glyph Texture</a></li>
    </ul>
  </ul>
  <li>Misc</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-setup-and-installation.html">WebGL Setup And Installation</a></li>
    <li><a href="/webgl/lessons/webgl-boilerplate.html">WebGL Boilerplate</a></li>
    <li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">WebGL Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/webgl-animation.html">WebGL - Animation</a></li>
    <li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL and Alpha</a></li>
    <li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">WebGL - 2D vs 3D libraries</a></li>
    <li><a href="/webgl/lessons/webgl-anti-patterns.html">WebGL - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/webgl-fundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Skinning';
            var disqus_title = 'WebGL Skinning';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



