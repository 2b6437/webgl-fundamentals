<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-text-texture.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL текст - текстуры" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Отображение текста в WebGL с помощью текстур" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL текст - текстуры" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-text-texture.html" />
<meta name="twitter:description" content="Отображение текста в WebGL с помощью текстур" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL текст - текстуры</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-text-texture.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/pl/webgl-text-texture.html" >Polski</a>
    <option value="/webgl/lessons/ru/webgl-text-texture.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL текст - текстуры</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает серию статей о WebGL. Последняя была об
<a href="webgl-text-canvas2d.html">использовании canvas 2D для отрисовки текста над элементом canvas
в WebGL</a>. Если вы её ещё не читали, предлагаю
сначала ознакомиться с ней.</p>
<p>В последней статье мы узнали, <a href="webgl-text-canvas2d.html">как использовать 2D-canvas для отображения
текста над сценой WebGL</a>. Этот подход работает
и реализуется довольно легко, однако, у него есть ограничение - текст всегда
находится на переднем плане и не может перекрыться объектами сцены. Чтобы
добиться перекрытия, нам нужно отображать текст средствами WebGL.</p>
<p>Самый простой способ - создать текстуры с текстом внутри них. Например, можно
зайти в фотошоп или какой-нибудь другой графический редактор  и создать
изображение с текстом внутри него.</p>
<p><img class="webgl_center" src="../resources/my-awesme-text.png" /></p>
<p>Затем создадим плоскую геометрию и отобразим её. Именно так отображали
весь текст некоторые игры, с которыми я работал. Например, игра Locoroco
содержала около 270 строк и была локализована на 17 языков. У нас был лист
Excel со всеми языками, а также скрипт, который запускал фотошоп и генерировал
текстуру - одну для каждого сообщения на каждом языке.</p>
<p>Конечно же, можно создавать текстуры на лету. Мы снова можем использовать
преимущество браузерного окружения и задействовать Canvas 2D API для
генерации наших текстур.</p>
<p>Начнём с примера из <a href="webgl-text-canvas2d.html">предыдущей статьи</a>
и добавим в него функцию для заполнения canvas 2D текстом.</p>
<pre><code>var textCtx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;);

// помещаем текст в центр canvas
function makeTextCanvas(text, width, height) {
  textCtx.canvas.width  = width;
  textCtx.canvas.height = height;
  textCtx.font = &quot;20px monospace&quot;;
  textCtx.textAlign = &quot;center&quot;;
  textCtx.textBaseline = &quot;middle&quot;;
  textCtx.fillStyle = &quot;black&quot;;
  textCtx.clearRect(0, 0, textCtx.canvas.width, textCtx.canvas.height);
  textCtx.fillText(text, width / 2, height / 2);
  return textCtx.canvas;
}
</code></pre><p>Так как нам нужно отрисовать два разных объекта в WebGL (букву F и текст)
я буду использовать <a href="webgl-drawing-multiple-things.html">функцию-помощник из предыдущей
статьи</a>. Если вещи вроде <code>programInfo</code>,
<code>bufferInfo</code> и другие вам непонятны, то загляните в предыдущую статью.</p>
<p>Итак, создадим букву &#39;F&#39; и единичный квадрант.</p>
<pre><code>// подготавливаем данные для буквы F
var fBufferInfo = primitives.create3DFBufferInfo(gl);
// создаём единичный квадрант для текста
var textBufferInfo = primitives.createPlaneBufferInfo(gl, 1, 1, 1, 1, m4.xRotation(Math.PI / 2));
</code></pre><p>Единичный квадрант - это квадрант (квадрат) единичного размера. Центр нашего
квадранта находится в начале системы координат. <code>createPlaneBufferInfo</code>
создаёт плоскость в плоскости xz. Мы передаём матрицу для поворота и получаем
единичный квадрант в плоскости xy.</p>
<p>Далее создаём два шейдера</p>
<pre><code>// настройка программы GLSL
var fProgramInfo = createProgramInfo(gl, [&quot;3d-vertex-shader&quot;, &quot;3d-fragment-shader&quot;]);
var textProgramInfo = createProgramInfo(gl, [&quot;text-vertex-shader&quot;, &quot;text-fragment-shader&quot;]);
</code></pre><p>И создаём текстуру текста.</p>
<pre><code>// создаём текстуру текста.
var textCanvas = makeTextCanvas(&quot;Hello!&quot;, 100, 26);
var textWidth  = textCanvas.width;
var textHeight = textCanvas.height;
var textTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, textTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
// отображаем текстуру, даже когда её размер не равен степени двойки
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>Устанавливаем uniform-переменные для текста и буквы &#39;F&#39;</p>
<pre><code>var fUniforms = {
  u_matrix: m4.identity(),
};

var textUniforms = {
  u_matrix: m4.identity(),
  u_texture: textTex,
};
</code></pre><p>Теперь при вычислении матриц для F мы сохраняем матрицу вида для буквы.</p>
<pre><code>var fViewMatrix = m4.translate(viewMatrix,
    translation[0] + xx * spread, translation[1] + yy * spread, translation[2]);
fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
</code></pre><p>Отрисовка F выглядит следующим образом.</p>
<pre><code>gl.useProgram(fProgramInfo.program);

webglUtils.setBuffersAndAttributes(gl, fProgramInfo, fBufferInfo);

fUniforms.u_matrix = m4.multiply(projectionMatrix, fViewMatrix);

webglUtils.setUniforms(fProgramInfo, fUniforms);

// отрисовка геометрии
gl.drawElements(gl.TRIANGLES, fBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
</code></pre><p>Для вывода текста нам нужно положение начальной точки F. Также нам нужно
масштабировать наш единичный квадрант, чтобы он соответствовал размерам
текстуры. Наконец, нам нужно умножить всё это на проекционную матрицу.</p>
<pre><code>// для текста используем положение вида буквы &#39;F&#39;
var textMatrix = m4.translate(projectionMatrix,
    fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]);
// масштабируем квадрант до нужного размера
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>И отображаем текст.</p>
<pre><code>// предварительные настройки для отображения текста
gl.useProgram(textProgramInfo.program);

webglUtils.setBuffersAndAttributes(gl, textProgramInfo, textBufferInfo);

m4.copy(textMatrix, textUniforms.u_matrix);
webglUtils.setUniforms(textProgramInfo, textUniforms);

// отображаем текст
gl.drawElements(gl.TRIANGLES, textBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
</code></pre><p>И вот результат.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вы можете заметить, что иногда части нашего текста закрывают части буквы F.
Это происходит из-за отрисовки квадранта. Цвет по умолчанию для canvas -
чёрный прозрачный (0,0,0,0), и этот цвет мы отображаем в квадранте. Для решения
проблемы будем использовать смешивание пикселей.</p>
<pre><code>gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>Пиксель источника (цвет из фрагментного шейдера) соединится с пикселем в
приемника (цвет canvas) в соответствии с функцией смешивания. Мы установили
функции смешивания <code>SRC_ALPHA</code> для источника и <code>ONE_MINUS_SRC_ALPHA</code> для
приемника, значит</p>
<pre><code>result = dest * (1 - src_alpha) + src * src_alpha
</code></pre><p>Например, если в приемнике зелёный цвет <code>0,1,0,1</code>, а в источнике -
красный <code>1,0,0,1</code>, то мы получим</p>
<pre><code>src = [1, 0, 0, 1]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // равно 1
result = dst * (1 - src_alpha) + src * src_alpha

// что можно упростить до
result = dst * 0 + src * 1

// и ещё раз упростить до
result = src
</code></pre><p>Для частей текстуры с прозрачным чёрным цветом <code>0,0,0,0</code></p>
<pre><code>src = [0, 0, 0, 0]
dst = [0, 1, 0, 1]
src_alpha = src[3]  // равно 0
result = dst * (1 - src_alpha) + src * src_alpha

// что можно упростить до
result = dst * 1 + src * 0

// и ещё раз упростить до
result = dst
</code></pre><p>Вот результат использования смешивания.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-enable-blend.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-enable-blend.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Стало лучше, но по-прежнему есть недостатки. Если вы приглядитесь,
то иногда заметите такую проблему:</p>
<p><img class="webgl_center" src="../resources/text-zbuffer-issue.png" /></p>
<p>Что происходит? Мы отрисовываем букву F, затем её текст. Затем следующую
F и её текст и так далее. <a href="webgl-3d-orthographic.html">Буфер глубины</a>
включён, поэтому при отрисовке текста для F, даже не смотря на то, что в
режиме смешивания некоторые пиксели остаются с цветом фона, буфер всё
равно обновляется. А когда мы отображаем следующую F, если части F
находятся позади этих пикселей от предыдущего текста, то эти части не
будут отображены.</p>
<p>Мы только что столкнулись с одной из самых сложных проблем в рендеринге
3D на видеокарте. <strong>Прозрачность несёт в себе множество опасностей</strong>.</p>
<p>Наиболее распространённый подход для отображения прозрачных объектов -
отрисовывать сначала все непрозрачные объекты, затем все прозрачные,
которые упорядочену по расстоянию по z с включённым тестированием буфера
глубины и отключённым обновлением буфера.</p>
<p>Давайте для начала отделим отрисовку непрозрачных объектов (буквы F) от
прозрачных (текст). Для начала заведём переменную, где будем хранить
положения для текста.</p>
<pre><code>var textPositions = [];
</code></pre><p>И при цикле отрисовки букв F мы будем запоминать эти положения.</p>
<pre><code>var fViewMatrix = m4.translate(viewMatrix,
    translation[0] + xx * spread, translation[1] + yy * spread, translation[2]);
fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
+// запоминаем положение вида буквы F
+textPositions.push([fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]]);
</code></pre><p>Перед отрисовкой букв F мы отключим смешивание и включим запись в буфер глубины.</p>
<pre><code>gl.disable(gl.BLEND);
gl.depthMask(true);
</code></pre><p>Для текста мы включим смешивание и отключим запись в буфер глубины.</p>
<pre><code>gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.depthMask(false);
</code></pre><p>И далее отрисуем текст во всех сохранённых положениях.</p>
<pre><code>+// предварительные настройки для отображения текста
+gl.useProgram(textProgramInfo.program);
+
+webglUtils.setBuffersAndAttributes(gl, textProgramInfo, textBufferInfo);

+textPositions.forEach(function(pos) {
  // отображаем текст

  // для текста используем положение вида буквы &#39;F&#39;
*  var textMatrix = m4.translate(projectionMatrix, pos[0], pos[1], pos[2]);
  // масштабируем квадрант до нужного размера
  textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);

  m4.copy(textMatrix, textUniforms.u_matrix);
  webglUtils.setUniforms(textProgramInfo, textUniforms);

  // отображаем текст
  gl.drawElements(gl.TRIANGLES, textBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
+});
</code></pre><p>Обратите внимание, что мы вынесли установку текущей программы и атрибутов
за пределы цикла, так как мы отрисовываем один и тот же объект несколько
раз и нет смысла устанавливать их каждую итерацию.</p>
<p>И теперь оно почти работает.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-separate-opaque-from-transparent.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-separate-opaque-from-transparent.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Как видите, мы не упорядочивали объекты, о чём я говорил выше. Мы отображаем
непрозрачный текст, поэтому сортировка не даст заметной разницы, а значит
я приберегу сортировку для какой-нибудь другой статьи.</p>
<p>Ещё одна проблема заключается в том, что текст пересекается со своей буквой &#39;F&#39;.
Какого-то универсального решения для этой ситуации нет. Если вам доведётся
делать игру в жанре ММО, и понадобится надпись для каждого игрока, то, возможно,
вы решите разместить надпись над головой персонажа. Просто прибавьте к значению
Y некоторое число, чтобы надпись была всегда выше игрока.</p>
<p>Или же можно сдвинуть надпись ближе к камере. Так и сделаем, просто ради
эксперимента. &#39;pos&#39; находится в пространстве вида, то есть он расположен
относительно наблюдателя (который находится в координатах 0,0,0). Поэтому
при его нормализации мы получим единичный вектор, направленный от наблюдателя
к координате, и при умножении этого вектора на определённое число надпись
сдвинется на несколько единиц по направлению к наблюдателю (или от него).</p>
<pre><code>+// pos находится в пространстве вида - то есть является вектором от наблюдателя
+// к координате. Поэтому сместимся вдоль этого вектора ближе к наблюдателю.
+var fromEye = m4.normalize(pos);
+var amountToMoveTowardEye = 150;  // длина буквы F составляет 150 единиц
+var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
+var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
+var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;
+var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);

*var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
// масштабируем F до нужного размера
textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
</code></pre><p>И вот, что мы получим</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-moved-toward-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-moved-toward-view.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Осталась ещё одна нерешённая проблема, которую можно увидеть на границах букв.</p>
<p><img class="webgl_center" src="../resources/text-gray-outline.png" /></p>
<p>Всё дело в том, что Canvas 2D API даёт на выходе только предумноженную
прозрачность. При загрузке содержимого canvas в текстуру WebGL пытается
получить не предумноженную прозрачность, но у него не получается сделать
это идеально, так как предумножение прозрачности идёт с потерями.</p>
<p>Чтобы поправить ситуацию, скажем WebGL, чтобы он не получал предумноженную прозрачность.</p>
<pre><code>gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
</code></pre><p>Эта строчка говорит WebGL, что нужно передать предумноженную прозрачность в
<code>gl.texImage2D</code> и <code>gl.texSubImage2D</code>. Если данные для <code>gl.texImage2D</code> уже
предумноженные, как в случае с Canvas 2D, то WebGL сможет просто передать
их далее.</p>
<p>Кроме того, нам нужно изменить функцию смешивания.</p>
<pre><code>-gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
+gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
</code></pre><p>Старая функция умножала цвет источника на его прозрачность. За это отвечает
<code>SRC_ALPHA</code>. Но сейчас данные для текстуры уже предумноженные на прозрачность.
Это и есть смысл предумножения. Поэтому нам не нужно заставлять видеокарту
выполнять умножение. Значение параметра <code>ONE</code> означает умножение на 1.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-premultiplied-alpha.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-premultiplied-alpha.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Теперь на краях букв пропала размытость.</p>
<p>А что, если нам нужно, чтобы текст оставался фиксированного размера, но
по-прежнему находился на переднем плане? Как вы помните из <a href="webgl-3d-perspective.html">статьи о
перспективе</a>, наша матрица перспективы
масштабирует объекты на значение <code>1 / -Z</code>, чтобы они были меньше на расстоянии.
Поэтому нам нужно лишь компенсировать этот коэффициент, масштабируя на <code>-Z</code>.</p>
<pre><code>...
// pos находится в пространстве вида - то есть является вектором от наблюдателя
// к координате. Поэтому сместимся вдоль этого вектора ближе к наблюдателю.
var fromEye = normalize(pos);
var amountToMoveTowardEye = 150;  // длина буквы F составляет 150 единиц
var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;
+var desiredTextScale = -1 / gl.canvas.height;  // 1x1 пикселей
+var scale = viewZ * desiredTextScale;

var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
// масштабируем F до нужного размера
*textMatrix = m4.scale(textMatrix, textWidth * scale, textHeight * scale, 1);
...
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-consistent-scale.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-consistent-scale.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Мы можем установить разные надписи для каждой буквы F, нужно лишь задать новую
текстуру для каждой F, а затем просто обновлять uniform-переменную для этой F.</p>
<pre><code>// создаём текстуры с текстом, по одной на каждую F
var textTextures = [
  &quot;anna&quot;,   // 0
  &quot;colin&quot;,  // 1
  &quot;james&quot;,  // 2
  &quot;danny&quot;,  // 3
  &quot;kalin&quot;,  // 4
  &quot;hiro&quot;,   // 5
  &quot;eddie&quot;,  // 6
  &quot;shu&quot;,    // 7
  &quot;brian&quot;,  // 8
  &quot;tami&quot;,   // 9
  &quot;rick&quot;,   // 10
  &quot;gene&quot;,   // 11
  &quot;natalie&quot;,// 12,
  &quot;evan&quot;,   // 13,
  &quot;sakura&quot;, // 14,
  &quot;kai&quot;,    // 15,
].map(function(name) {
  var textCanvas = makeTextCanvas(name, 100, 26);
  var textWidth  = textCanvas.width;
  var textHeight = textCanvas.height;
  var textTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
  // make sure we can render it even if it&#39;s not a power of 2
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return {
    texture: textTex,
    width: textWidth,
    height: textHeight,
  };
});
</code></pre><p>Затем при отрисовке выбираем текстуру</p>
<pre><code>*textPositions.forEach(function(pos, ndx) {

  +// выбираем текстуру
  +var tex = textTextures[ndx];

  var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
  // масштабируем F до нужного размера
  *textMatrix = m4.scale(textMatrix, tex.width * scale, tex.height * scale, 1);
</code></pre><p>и обновляем значение uniform-переменной перед отрисовкой.</p>
<pre><code>  *textUniforms.u_texture = tex.texture;
</code></pre><p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-text.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-text.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Мы использовали чёрный цвет для текста. Было бы полезно использовать белый
цвет для текста. Тогда мы могли бы умножить текст на цвет и получить в итоге
цветной текст.</p>
<p>Для начала внесём изменения в шейдер текста для умножения на цвет.</p>
<pre><code>varying vec2 v_texcoord;

uniform sampler2D u_texture;
+uniform vec4 u_color;

void main() {
*   gl_FragColor = texture2D(u_texture, v_texcoord) * u_color;
}
</code></pre><p>Далее при отрисовке текста в canvas будем использовать белый цвет.</p>
<pre><code>textCtx.fillStyle = &quot;white&quot;;
</code></pre><p>Теперь создадим цвета надписей.</p>
<pre><code>// цвета, по 1 на каждую F
var colors = [
  [0.0, 0.0, 0.0, 1], // 0
  [1.0, 0.0, 0.0, 1], // 1
  [0.0, 1.0, 0.0, 1], // 2
  [1.0, 1.0, 0.0, 1], // 3
  [0.0, 0.0, 1.0, 1], // 4
  [1.0, 0.0, 1.0, 1], // 5
  [0.0, 1.0, 1.0, 1], // 6
  [0.5, 0.5, 0.5, 1], // 7
  [0.5, 0.0, 0.0, 1], // 8
  [0.0, 0.0, 0.0, 1], // 9
  [0.5, 5.0, 0.0, 1], // 10
  [0.0, 5.0, 0.0, 1], // 11
  [0.5, 0.0, 5.0, 1], // 12,
  [0.0, 0.0, 5.0, 1], // 13,
  [0.5, 5.0, 5.0, 1], // 14,
  [0.0, 5.0, 5.0, 1], // 15,
];
</code></pre><p>При отрисовке устанавливаем цвет</p>
<pre><code>// задаём значение для uniform-переменной цвета
textUniforms.u_color = colors[ndx];
</code></pre><p>И получаем цветные надписи.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-text-texture-different-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-text-texture-different-colors.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Такую технику использует большая часть браузеров, когда они используют
аппаратное ускорение. Браузер создаёт текстуру из контента вашего HTML и
всевозможных стилей, которые вы назначили, и до тех пор, пока контент не
меняется, браузер отображает текстуру снова при скроле и прочем. Конечно
же, если вы обновляете контент часто, то такая техника может работать
немного медленно, так как нужно пересоздавать текстуры и передавать новые
текстуры в видеокарту, что является относительно медленными операциями.</p>
<p>В <a href="webgl-text-glyphs.html">следующей статье мы познакомимся с техникой, которая больше подходит для
случаев, когда объекты часто меняются</a>.</p>
<div class="webgl_bottombar">
<h3>Масштабирование текста без пикселизации</h3>
<p>
Вы могли заметить, что в примерах до использования постоянного размера текста
буквы подвергались пикселизации при приближении к камере. Как этого избежать?
</p>
<p>
Честно говоря, масштабирование 2D-текста в 3D - не частая задача. Взять те же
игры или редакторы 3D - текст почти всегда одного размера, независимо от
того, как далеко от камеры он расположен. Часто текст может быть отрисован в 2D
вместо 3D, поэтому даже когда кто-то или что-то находится за препядствием -
например, персонаж за стеной - вы по-прежнему будете видеть текст.
</p>
<p>Если вам всё же придётся масштабировать 2D-текст в 3D, я не знаю каких-либо
простых вариантов. Вот несколько навскидку:</p>
<ul>
<li>Сделайте различные размеры текстур со шрифтами для разных разрешений. Затем
используйте текстуры с более высоким разрешением при увеличении текста. Это
приём называется LOD (различные уровни детализации).</li>
<li>Также можно отображать текстуры с точно соответствующим размером шрифта
на каждый кадр. Скорей всего это будет очень медленно.</li>
<li>Можно создать 2D-текст с помощью геометрии. Другими словами, вместо
отрисовки текста в текстуру можно создать текст из множества треугольников.
Это будет работать, однако маленький текст отобразится очень плохо, а у большого
текста будут заметны треугольники.</li>
<li>Ещё можно <a href="https://www.google.com/search?q=loop+blinn+curve+rendering">использовать специальные шейдеры для отображения кривых</a>.
Это очень круто, но находится далеко за гранью того, что я здесь объясняю.
</li>
</ul>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-text-texture.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-text-texture.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-text-texture.html" >日本語</a>
    <option value="/webgl/lessons/pl/webgl-text-texture.html" >Polski</a>
    <option value="/webgl/lessons/ru/webgl-text-texture.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-text-texture.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>
  <li>Основы</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
  </ul>
  <li>Обработка изображений</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
  </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
  </ul>
  <li>Освещение</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
  </ul>
  <li>Структура и устройство</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
    <li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
    <li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
  </ul>
  <li>Геометрия</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели (en)</a></li>
  </ul>
  <li>Текстуры</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
    <li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
  </ul>
  <li>Приёмы</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a>
      <li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a>
    </ul>
    <li>Текст</li>
    <ul>
      <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a>
      <li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a>
      <li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a>
      <li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a>
    </ul>
  </ul>
  <li>Разное</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
    <li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
    <li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
    <li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/greggman/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL текст - текстуры';
            var disqus_title = 'WebGL текст - текстуры';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



