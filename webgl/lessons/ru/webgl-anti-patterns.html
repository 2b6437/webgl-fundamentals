<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-anti-patterns.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Gregg Tavares. nor the names of his
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL - Антипаттерны" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Что и почему не нужно делать в WebGL, и что следует использовать" />
<meta property="og:url" content="http://webglfundamentals.org//webgl/lessons/ru/webgl-anti-patterns.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL - Антипаттерны" />
<meta name="twitter:url" content="http://webglfundamentals.org//webgl/lessons/ru/webgl-anti-patterns.html" />
<meta name="twitter:description" content="Что и почему не нужно делать в WebGL, и что следует использовать" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL - Антипаттерны</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/base.css" type="text/css" />
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_header">
  <h1><a href="/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL - Антипаттерны</h1>
  </div>
  <div class="row">
    <div class="col-sm-8 lesson-main">
      <p>Ниже приведён список антипаттернов в WebGL. Антипаттерны - это вещи, которых стоит избегать.</p>
<ol>
<li><p>Добавление свойств <code>viewportWidth</code> и <code>viewportHeight</code> объекту <code>WebGLRenderingContext</code></p>
<p>Порой можно встретить, что значения ширины и высоты области просмотра
записываются в свойства объекта <code>WebGLRenderingContext</code>, например так:</p>
<pre class="prettyprint">
gl = canvas.getContext("webgl");
gl.viewportWidth = canvas.width;    // ПЛОХО!!!
gl.viewportHeight = canvas.height;  // ПЛОХО!!!
</pre>

<p>Затем свойства могут использоваться следующим образом:</p>
<pre class="prettyprint">
gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Это объективно плохо, потому что теперь у вас появляется 2 свойства, которые
нужно не забывать обновлять каждый раз при изменении размера canvas. Например,
при изменении размера окна пользователем свойства <code>gl.viewportWidth</code> и
<code>gl.viewportHeight</code> будут некорректными, их нужно обновить согласно новым
размерам canvas.</p>
<p>Это субъективно плохо, потому что новички в WebGL посмотрят на ваш код и
подумают, что <code>gl.viewportWidth</code> и <code>gl.viewportHeight</code> - часть спецификации
WebGL, что введёт их в заблуждение, возможно, на месяцы.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Зачем создавать себе больше работы? Контекст WebGL уже содержит ширину и
высоту. Просто используйте их.</p>
<pre class="prettyprint">
// если вам необходимо, чтобы область просмотра соответствовала размеру
// буфера отрисовки canvas'а, это всегда будет работать
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
</pre>

<p>Такой подход даже лучше справится со сложными случаями, где использование
<code>gl.canvas.width</code> и <code>gl.canvas.height</code> не поможет. <a href="#drawingbuffer">Объяснение смотри ниже</a>.</p>
</li>
<li><p>Использование <code>canvas.width</code> и <code>canvas.height</code> для соотношения сторон экрана</p>
<p>Часто можно увидеть код, использующий <code>canvas.width</code> и <code>canvas.height</code> для
соотношения сторон экрана, например:</p>
<pre class="prettyprint">
var aspect = canvas.width / canvas.height;
perspective(fieldOfView, aspect, zNear, zFar);
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Ширина и высота canvas никак не связана с тем размером, как canvas отображается
на странице. За размер canvas на странице отвечает CSS.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Используйте <code>canvas.clientWidth</code> и <code>canvas.clientHeight</code>. Эти размеры вернут
реальный размер отображаемого на экране canvas. Используя эти свойства, у вас
всегда будет правильное соотношение сторон экрана, независимо от CSS.</p>
<pre class="prettyprint">
var aspect = canvas.clientWidth / canvas.clientHeight;
perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
</pre>

<p>Ниже идут несколько примеров canvas с одинаковым размером (<code>width=&quot;400&quot; height=&quot;300&quot;</code>),
но через CSS мы задаём разный размер отображения в браузере. Заметьте, что
примеры сохраняют корректное соотношение сторон экрана.</p>
<p><div>
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>


<p></p>
<div>
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html"></iframe>
</div>

</p>
<p>А если мы используем <code>canvas.width</code> и <code>canvas.height</code>, изображение искажается.</p>
<p><div>
  <iframe class="webgl_example " style="width: 150px; height: 200px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>


<p></p>
<div>
  <iframe class="webgl_example " style="width: 400px; height: 150px;" src="/webgl/lessons/../webgl-canvas-width-height.html"></iframe>
</div>

</p>
</li>
<li><p>Использование для вычислений <code>window.innerWidth</code> и <code>window.innerHeight</code></p>
<p>Многие программы WebGL используют <code>window.innerWidth</code> и <code>window.innerHeight</code>
во многих местах. Например:</p>
<pre class="prettyprint">
canvas.width = window.innerWidth;                    // ПЛОХО!!
canvas.height = window.hinnerHeight;                 // ПЛОХО!!
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Это не переносится. Да, это будет работать на HTML-страницах, где вы хотите растянуть
canvas на весь экран. Проблема появится, когда полноэкранный режим станет не нужен.
Возможно, вы решите сделать статью подобную моей, где canvas - лишь небольшая часть
большой страницы. А может сбоку вам нужен редактор свойств или статистика по игре.
Конечно, вы сможете обойти эти ситуации, но почему бы сразу не написать код так,
чтобы он работал везде? Тогда вам не придётся менять его при создании нового проекта
или использование старого проекта по-новому.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Вместо того, чтобы бороться с веб-страницей, сотрудничайте с ней! Используйте
CSS вместе с <code>clientWidth</code> и <code>clientHeight</code>.</p>
<pre class="prettyprint">
var width = gl.canvas.clientWidth;
var height = gl.canvas.clientHeight;

gl.canvas.width = width;
gl.canvas.height = height;
</pre>

<p>Ниже приведены 9 примеров. Все они используют один и тот же код. Ни один из
них не использует ни <code>window.innerWidth</code>, ни <code>window.innerHeight</code>.</p>
<p><a href="../../webgl-same-code-canvas-fullscreen.html" target="_blank">Страница с единственным элементом canvas, растянутым на весь экран через CSS</a></p>
<p><a href="../../webgl-same-code-canvas-partscreen.html" target="_blank">Страница с canvas размером 70% ширины страницы, чтобы осталось место для контрольной панели</a></p>
<p><a href="../../webgl-same-code-canvas-embedded.html" target="_blank">Страница с canvas внутри параграфа</a></p>
<p><a href="../../webgl-same-code-canvas-embedded-border-box.html" target="_blank">Страница с canvas внутри параграфа, использует <code>box-sizing: border-box;</code></a></p>
<p>При использовании <code>box-sizing: border-box;</code> границы и внутренние отступы забирают пространство самого элемента, а не области вокруг него.
Другими словами, в обычном режиме box-sizing элемент размером 400x300 пикселей с границей толщиной 15 пикселей будет содержать 400x300 пикселей контента
и будет окружён границей толщиной 15 пикселей, то есть итоговый размер составит 430x330 пикселей. В режиме box-sizing: border-box граница уйдёт внутрь,
поэтому суммарный размер элемента останется 400x300 пикселей, а контент займёт 370x270 пикселей. Это ещё одна причина, по которой вам нужно использовать
<code>clientWidth</code> и <code>clientHeight</code>. При установки ширины границы, скажем, <code>1em</code> вы не будете знать, какой размер у неё будет, так как он будет разным в
зависимости от шрифта, компьютера, браузера.</p>
<p><a href="../../webgl-same-code-container-fullscreen.html" target="_blank">Страница, содержащая только контейнер, которому через CSS задан полноэкранный размер, и в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-partscreen.html" target="_blank">Страница с контейнером шириной 70%, чтобы оставить место для панели управления, в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-embedded.html" target="_blank">Страница с контейнером, вставленным в параграф, в который через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-container-embedded-border-box.html" target="_blank"> Страница с контейнером, вставленным в параграф, используется <code>box-sizing: border-box;</code>, в контейнер через код вставлен canvas</a></p>
<p><a href="../../webgl-same-code-body-only-fullscreen.html" target="_blank">Страница без элементов, настроенная через CSS для полноэкранного режима, в которую через код вставлен canvas</a></p>
<p>Повторюсь, что смысл в том, чтобы при написании кода, используя описанные
техники, вам не пришлось менять код, сталкиваясь с различными ситуациями.</p>
</li>
<li><p>Использование события <code>&#39;resize&#39;</code> для изменения размера canavs</p>
<p>Некоторые приложения отслеживают событие <code>&#39;resize&#39;</code>, чтобы подстроить размер canavs.</p>
<pre class="prettyprint">
window.addEventListener('resize', resizeTheCanvas);
</pre>

<p>или так</p>
<pre class="prettyprint">
window.onresize = resizeTheCanvas;
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Само по себе это не плохо. Просто для <em>большинства</em> программ на WebGL такое
решение не охватывает некоторых ситуаций. Событие <code>&#39;resize&#39;</code> срабатывает, только
когда размер окна меняется. Оно не сработает, если по каким-то причинам изменился
размер canvas. Например, вы делаете 3D-редактор. Ваш canvas находится слева,
настройки расположены справа. И у вас есть возможность расширять или сужать
панель настроек, потянув за границу между настройками и canvas. В этом случае
не будет никакого события <code>&#39;resize&#39;</code>. Аналогично, при добавлении или удалении
контента на страницу размер canvas может меняться, и вы тоже не получите события
<code>&#39;resize&#39;</code>.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Как и во многих решениях выше, в данном случае есть способ написать код так, чтобы
он работал в большинстве ситуаций. Для приложений WebGL, которые постоянно
отображают каждый кадр, можно проверять размер перед отрисовкой, и в зависимости
от результата обновлять размер.</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
  }
}

function render() {
   resize();
   drawStuff();
   requestAnimationFrame(render);
}
render();
</pre>

<p>Теперь во всех описанных выше ситуациях canvas будет всегда иметь правильный
размер. Нет необходимости менять код для отдельных случаев. Например, используя
код из примера #3, сделаем редактор с возможностью менять размер панели настроек.</p>
<p><div>
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/../webgl-same-code-resize.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-same-code-resize.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>В этом примере не будет события изменений размера, как и в других случаях, когда
размер canvas меняется динамически в зависимости от других элементов страницы.</p>
<p>Для приложений, где не отрисовывается каждый кадр, код по-прежнему будет работать,
вам нужно лишь вызывать перерисовку при изменении размера canvas. Одним из решений
будет использование цикла requestAnimationFrame следующим образом:</p>
<pre class="prettyprint">
function resize() {
  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  if (gl.canvas.width != width ||
      gl.canvas.height != height) {
     gl.canvas.width = width;
     gl.canvas.height = height;
     return true;
  }
  return false;
}

var needToRender = true;  // необходимо отрисовать хотя бы раз
function checkRender() {
   if (resize() || needToRender) {
     needToRender = false;
     drawStuff();
   }
   requestAnimationFrame(checkRender);
}
checkRender();
</pre>

<p>Здесь отрисовка будет происходить только в том случае, когда размер canvas изменился
или значение <code>needToRender</code> равно true. Таким образом мы решим проблему изменения
размера в приложениях, которые не отрисовывают каждый кадр. Просто установите
<code>needToRender</code> в значение true, когда на сцене что-то изменилось, и вы хотите
отрисовать сцену, чтобы отразить эти изменения.</p>
</li>
<li><p>Добавление свойств к объектам <code>WebGLObject</code></p>
<p>Объекты <code>WebGLObject</code> - это различные виды ресурсов в WebGL, например, <code>WebGLBuffer</code>
или <code>WebGLTexture</code>. Некоторые приложения добавляют свои свойства к этим объектам.
Например, код может выглядеть так:</p>
<pre class="prettyprint">
var buffer = gl.createBuffer();
buffer.itemSize = 3;        // ПЛОХО!!
buffer.numComponents = 75;  // ПЛОХО!!

var program = gl.createProgram();
...
program.u_matrixLoc = gl.getUniformLocation(program, "u_matrix");  // ПЛОХО!!
</pre>

<p><strong>Почему это плохо:</strong></p>
<p>Причина заключается в том, что WebGL может &quot;потерять контекст&quot;&quot;. Это может случиться по
многим причинам, но чаще всего возникает ситуация, когда браузер решает, что используется
слишком много ресурсов видеокарты, и вытесняет контекст некоторых <code>WebGLRenderingContext</code>,
чтобы освободить память. Программам WebGL, работающим без остановки, необходимо отлавливать
эту ситуацию. Например, Google Maps обрабатывает такую ситуацию.</p>
<p>Проблема упомянутого кода в том, что при потере контекста теряются и функции создания
объектов, например <code>gl.createBuffer()</code> вернёт <code>null</code>. Поэтому следующий код</p>
<pre class="prettyprint">
var buffer = null;
buffer.itemSize = 3;        // ОШИБКА!
buffer.numComponents = 75;  // ОШИБКА!
</pre>

<p>скорей всего прекратит выполнение вашего приложение с ошибкой</p>
<pre class="prettyprint">
TypeError: Cannot set property 'itemSize' of null
</pre>

<p>Многим приложениям не важно, если они завершатся по ошибке при потере контекста, но всё
же это является плохой практикой, потому что разработчику придётся исправлять код, если
ему понадобится обрабатывать ситуацию с потерей контекста.</p>
<p><strong>Что делать вместо этого:</strong></p>
<p>Если вам нужно сохранить <code>WebGLObjects</code> и другую информации в одном месте, одним
из способов будет использование объектов JavaScript. Например:</p>
<pre class="prettyprint">
var bufferInfo = {
  id: gl.createBuffer(),
  itemSize: 3,
  numComponents: 75,
};

var programInfo = {
  id: program,
  u_matrixLoc: gl.getUniformLocation(program, "u_matrix"),
};
</pre>

<p>Лично я бы предложил использовать <a href="webgl-less-code-more-fun.html">несколько простых
помощников, которые облегчат написание кода WebGL</a>.</p>
</li>
</ol>
<p>Описанные выше ситуации, которые я отношу к антипаттернам WebGL, я встретил на просторах
интернета. Надеюсь, я показал, почему их нужно избегать, а приведённые решение будут
вам полезны.</p>
<div class="webgl_bottombar"><a id="drawingbuffer"/><h3>Что такое drawingBufferWidth и drawingBufferHeight?</h3>
<p>
В видеокарте есть ограничение на размер прямоугольника пикселей (текстуры, буфера отрисовки). Обычно этот
размер является степенью двойки и при этом превышает разрешение монитора, которое распространено на момент
выпуска видеокарты. Например, если видеокарта выпущена для мониторов 1280x1024, её ограничением скорей
всего будет значение 2048. В случае с мониторами разрешением 2560x1600 ограничение видеокарты составит 4096.
</p><p>
Это кажется разумным, но что случится, если у вас несколько мониторов? Скажем, у меня видеокарта с
ограничением 2048, но у меня два монитора 1920x1080. Пользователь откроет окно браузера со страницей
WebGL и растянет окно на два монитора. Ваш код попытается установить <code>canvas.width</code> в значение
<code>canvas.clientWidth</code> , которое в данный момент равно 3840. Что произойдёт?
<p>У меня сходу есть 3 варианта</p>
<ol>
<li>
 <p>Исключение</p>
 <p>Плохой сценарий. Большинство приложений не проверят это исключение и прервут
 выполнение. Если в приложении были данные пользователя, они потеряются.</p>
</li>
<li>
 <p>Ограничить размер canvas до ограничения видеокарты</p>
 <p>Это решение тоже, вероятно, приведёт к прерыванию работы программы или другим проблемам
 на странице, так как код ожидает, что размер canvas будет другим, и что другие части
 интерфейса будут на своих местах страницы.</p>
</li>
<li>
 <p>Размер canvas может быть любым, но буфер отрисовки будет ограничен</p>
 <p>Это решение, которое использует WebGL. Если ваш код написан верно, пользователь сможет заметить лишь то,
 что изображение на canvas немного растянулось. В других случаях всё будет в порядке. В худшем случае,
 когда ваш код написан не совсем корректно, пользователь увидит смещение картинки, но при уменьшении
 размера окна картинка будет отображаться нормально.</p>
</li>
</ol>
<p>У большинства пользователей один монитор, поэтому проблема возникает редко. Или, по крайней мере,
возникала редко. Chrome и Safari, во всяком случае на январь 2015 года, имели встроенное ограничение
canvas 4096. У Apple iMac 5k ограничение было выше. Из-за этого многие приложения WebGL имели странности
с отображением. Аналогично многие люди начали использовать WebGL с двумя мониторами для работы с
инсталляциями и тоже достигли ограничения.</p>
<p>
Поэтому если вы хотите обработать эти случаи, используйте <code>gl.drawingBufferWidth</code> и
<code>gl.drawingBufferHeight</code>, как показано в примере #1. Для большинства приложений при следовании
советам, описанных выше, всё будет работать без проблем. Однако, если вы выполняете вычисления, для которых
нужен реальный размер буфера отрисовки, вам нужно принять во внимание описанное выше. Например, выбор
объектов сцены, где нужно преобразовать координаты мыши в пиксели canvas. Другой пример - пост-эффекты,
для которых нужно знать реальный размер буфера отрисовки.
</p>
</div>

      <hr class="lesson-comment-sep" />
      <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/greggman/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL - Антипаттерны';
            var disqus_title = 'WebGL - Антипаттерны';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div class="col-sm-3 col-sm-offset-1 lesson-sidebar">
        <select id="language">
</select>

        <ul>
  <li>Основы</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
  </ul>
  <li>Обработка изображений</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
  </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
  </ul>
  <li>Освещение</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
    <li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
  </ul>
  <li>Структура и устройство</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
    <li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
    <li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
  </ul>
  <li>Геометрия</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели (en)</a></li>
  </ul>
  <li>Текстуры</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
    <li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
  </ul>
  <li>Приёмы</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a>
      <li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a>
    </ul>
    <li>Текст</li>
    <ul>
      <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a>
      <li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a>
      <li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a>
      <li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a>
    </ul>
  </ul>
  <li>Разное</li>
  <ul>
    <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
    <li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
    <li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
    <li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
    <li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
    <li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/greggman/webgl-fundamentals">github</a></li>
</ul>

    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="/langdb.js"></script>
<script src="/webgl/lessons/resources/languages.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



