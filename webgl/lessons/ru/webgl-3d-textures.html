<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-3d-textures.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 3D - Текстуры" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Как работают текстуры в WebGL" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-3d-textures.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 3D - Текстуры" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-3d-textures.html" />
<meta name="twitter:description" content="Как работают текстуры в WebGL" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 3D - Текстуры</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 3D - Текстуры</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает серию статей о WebGL. В первой из них
<a href="webgl-fundamentals.html">мы начали с основ WebGL</a>, а в предыдущей
<a href="webgl-animation.html">рассмотрели анимацию</a>.</p>
<p>Как применить текстуру в WebGL? Возможно, вы сможете разобраться из
статьи об <a href="webgl-image-processing.html">обработке изображений</a>, но
будет проще, если мы разберём всё сначала более подробно.</p>
<p>Первое, что нам нужно сделать - приспособить шейдер к использованию текстур.
Далее идут изменения в вершинном шейдере. Нам нужно передать в него текстурные
координаты. В данном случае мы передаём их без изменений сразу во фрагментный
шейдер.</p>
<pre class="prettyprint"><code>attribute vec4 a_position;
*attribute vec2 a_texcoord;

uniform mat4 u_matrix;

*varying vec2 v_texcoord;

void main() {
  // умножаем координаты на матрицу
  gl_Position = u_matrix * a_position;

*  // передаём текстурные координаты во фрагментный шейдер
*  v_texcoord = a_texcoord;
}
</code></pre><p>Во фрагментном шейдере мы объявляем uniform-переменную sampler2D, через
которую будем обращаться к текстуре. Мы используем текстурные координаты,
переданные из вершинного шейдера и вызваем функцию <code>texture2D</code> для
получения цвета из этой текстуры.</p>
<pre class="prettyprint"><code>precision mediump float;

// приходит из вершинного шейдера
*varying vec2 v_texcoord;

*// текстура
*uniform sampler2D u_texture;

void main() {
*   gl_FragColor = texture2D(u_texture, v_texcoord);
}
</code></pre><p>Нам необходимо настроить текстурные координаты.</p>
<pre class="prettyprint"><code>// получаем ссылку на данные вершины
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
*var texcoordLocation = gl.getAttribLocation(program, &quot;a_texcoords&quot;);

...

*// создаём буфер для текстурных координат
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
*gl.enableVertexAttribArray(texcoordLocation);
*
*// текстурные координаты - числа с плавающей точкой
*gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
*
*// задаём текстурные координаты
*setTexcoords(gl);
</code></pre><p>Текстурные координаты сопоставляют целую текстуру с каждой гранью
нашей буквы &#39;F&#39;.</p>
<pre class="prettyprint"><code>*// заполняем буфер текстурными координатами для F
*function setTexcoords(gl) {
*  gl.bufferData(
*      gl.ARRAY_BUFFER,
*      new Float32Array([
*        // лицевая часть столба слева
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
*
*        // лицевая часть верхней перекладины
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
* ...
*       ]),
*       gl.STATIC_DRAW);
</code></pre><p>Также нам понадобится текстура. Мы бы могли создать её сами, но в данном
случае просто загрузим изображение, так как это наиболее распространённый
способ.</p>
<p>Вот такое изображение мы будем использовать:</p>
<p><img class="webgl_center" src="../../resources/f-texture.png" /></p>
<p>Изображение отлично нам подходит! По изображению буквы &#39;F&#39; легко понять,
в какую сторону повёрнуто изображение при использовании текстуры.</p>
<p>Необходимо помнить, что изображение загружается асинхронно. Мы посылаем
запрос на загрузку изображения, а через некоторое время браузер скачивает
его. Есть 2 распространённых подхода для обхода этой ситуации. Мы могли бы
дожидаться, когда текстура загрузится, и лишь затем начинать отрисовку. А
можно использовать другую текстуру на время загрузки изображения. В последнем
случае мы могли бы начать отрисовку немедленно. А затем, когда изображение
загрузится, мы перенесли бы его в текстуру. Именно такой подход мы и будем
использовать далее.</p>
<pre class="prettyprint"><code>*// создаём текстуру
*var texture = gl.createTexture();
*gl.bindTexture(gl.TEXTURE_2D, texture);
*
*// заполняем текстуру голубым пикселем 1x1
*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
*              new Uint8Array([0, 0, 255, 255]));
*
*// асинхронная загрузка изображения
*var image = new Image();
*image.src = &quot;resources/f-texture.png&quot;;
*image.addEventListener(&#39;load&#39;, function() {
*  // теперь, когда изображение загрузилось, копируем его в текстуру
*  gl.bindTexture(gl.TEXTURE_2D, texture);
*  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
*  gl.generateMipmap(gl.TEXTURE_2D);
*});
</code></pre><p>И вот результат:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>А что, если нам понадобится использовать только часть текстуру для фронтальной части &#39;F&#39;? К текстурам
идёт обращение через &quot;текстурные координаты&quot;, которые идут в диапазоне от 0.0 до 1.0 слева направо
по текстуре и от 0.0 до 1.0 от первого пикселя первой строки до последнего пикселя последней строки.
Заметьте, что я не сказал &quot;верх&quot; или &quot;низ&quot;. Верх и низ не имеют смысла в пространстве
текстуры, потому что до тех пор, пока вы не отрисуете что-то и не зададите направления, не
будет верха или низа. Важно лишь, что вы передаёте текстурные данные в WebGL. Начало данных
начинается в текстурных координатах 0,0, а заканчиваются в 1,1.</p>
<p><img class="webgl_center noinvertdark" width="405" src="../resources/texture-coordinates-diagram.svg" /></p>
<p>Я загрузил текстуру в фотошоп и отметил необходимые координаты в пикселях.</p>
<p><img class="webgl_center" width="256" height="256" src="../../resources/f-texture-pixel-coords.png" /></p>
<p>Для конвертации из пиксельных координат в текстурные мы можем использовать формулу.</p>
<pre class="prettyprint"><code>texcoordX = pixelCoordX / (width  - 1)
texcoordY = pixelCoordY / (height - 1)
</code></pre><p>Вот текстурные координаты для фронтальной части.</p>
<pre class="prettyprint"><code>// лицевая часть левого столба
 38 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255, 223 / 255,
113 / 255,  44 / 255,

// лицевая часть верхней перекладины
113 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 85 / 255,
218 / 255, 44 / 255,

// лицевая часть средней перекладины
113 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 151 / 255,
203 / 255, 112 / 255,
</code></pre><p>Я использовал такие же текстурные координаты для задней стороны. И вот результат.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-coords-mapped.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-coords-mapped.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Пример нельзя назвать потрясающим, но надеюсь, что он наглядно демонстрирует
использование текстурных координат. Если вы создаёте геометрию в коде (куб,
сферу и прочее), вычислять текстурные координаты довольно легко. С другой
стороны, при использовании 3D-моделей редакторов 3D вроде Blender, Maya,
3D Studio Max, создатель модели сам задаст текстурные координаты в этих
редакторах.</p>
<p>А что же случится при использовании текстурных координат за пределами
диапазона от 0.0 до 1.0? По умолчанию WebGL повторит текстуру. От 0.0 до
1.0 находится одна копия текстуры. От 1.0 до 2.0 - вторая. И даже от -4.0
до -3.0 находится копия. Отобразим поверхность, используя следующие
текстурные координаты.</p>
<pre class="prettyprint"><code> -3, -1,
  2, -1,
 -3,  4,
 -3,  4,
  2, -1,
  2,  4,
</code></pre><p>Получится следующее:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-repeat-clamp.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-repeat-clamp.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вы можете повторять текстуру в определённых направлениях через <code>CLAMP_TO_EDGE</code>. Например,</p>
<pre class="prettyprint"><code>gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>Попробуйте разные переключатели в примере выше, чтобы понять разницу.</p>
<p>Вы могли заметить вызов функции <code>gl.generateMipmap</code> при загрузке текстуры.
Для чего она нужна?</p>
<p>Представьте, что у нас есть текстура 16x16 пикселей.</p>
<p><img class="webgl_center" src="../resources/mip-low-res-enlarged.png" style="border: 2px solid black;" /></p>
<p>Теперь представьте, что мы пытаемся отрисовать эту текстуру на полигоне
размером 2x2 пикселей на экране. Какой цвет будет у этих 4 пикселей?
Нужно выбрать из 256 пикселей. В фотошопе при масштабировании изображения
16x16 пикселей до изображения размером 2x2 в каждом углу уместится квадрат
8x8 пикселей, чтобы получить эти 4 пикселя в изображении 2x2. К сожалению,
чтение 64 пикселей и их усреднение даётся видеокарте не так легко. А теперь
представьте, что у вас текстура размером 2048x2084 пикселей и вы пытаетесь
уместить её в изображение размером 2x2. Для этого фотошоп для каждого из 4
пикселей в этом изображении 2x2 усреднит 1024x1024 пикселей (или миллион
пикселей) четыре раза. Довольно сложно это сделать, особенно учитывая, что
это нужно сделать быстро.</p>
<p>В этом случае видеокарта использует мипмапы. Мипмап - это набор уменьшающихся
изображений, каждое из которых в 4 раза меньше предыдущего. Мипмап для уже
знакомой нам текстуры 16x16 может выглядеть следующим образом:</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/mipmap-low-res-enlarged.png" /></p>
<p>Обычно каждое уменьшенное изображение - это просто билинейная интерполяция
предыдущего, и именно их создаёт функция <code>gl.generateMipmap</code>. Она берёт
самое большое изображение и создаёт все уменьшенные копии. Конечно же, вы
можете сделать уменьшенные изображения и сами.</p>
<p>Теперь, если вы попытаетесь отрисовать текстуру 16x16 пикселей на полигоне
2x2 пикселей, WebGL выберет уже готовое уменьшенное изображение размером 2x2
из мипмапа.</p>
<p>Вы можете выбрать одну из 6 моделей фильтра текстуры.</p>
<ul>
<li><code>NEAREST</code> = выбрать 1 пиксель из большего изображения</li>
<li><code>LINEAR</code> = выбрать 4 пикселя из большего изображения и смешать их</li>
<li><code>NEAREST_MIPMAP_NEAREST</code> = выбрать лучшее изображение (меньшее или большее) и выбрать 1 пиксель из него</li>
<li><code>LINEAR_MIPMAP_NEAREST</code> = выбрать лучшее изображение и смешать 4 пикселя из него</li>
<li><code>NEAREST_MIPMAP_LINEAR</code> = выбрать 2 лучших изображения, взять по 1 пикселю из каждого и смешать их</li>
<li><code>LINEAR_MIPMAP_LINEAR</code> = выбрать 2 лучших изображения, взять по 4 пикселя из каждого и смешать их</li>
</ul>
<p>На следующих 2 примерах можно увидеть разницу в этих моделях. Первый пример
демонстрирует использование <code>NEAREST</code> или <code>LINEAR</code>, где всегда берётся пиксель
из большего изображения, и поэтому изображение начинает мигать при движении
объекта. При такое модели необходимо всегда выбрать единственный пиксель из
большего изображение, а в зависимости от размера и положения изображения иногда
берётся один пиксель, а иногда - другой, поэтому мы получаем мерцание.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Обратите внимание, как сильно мерцают левые и средние изображения, в то время как правые мерцает
значительно меньше. Правые изображения тоже имеют смешанные цвета, так как они используют мипмапы.
Чем меньше текстура, тем дальше друг от друга WebGL берёт пиксели. Именно поэтому нижнее изображение
посередине, мерцает, даже не смотря на использование <code>LINEAR</code> и смешивание 4 пикселей - это происходит
из-за того, что эти 4 пикселя из разных углов изображения 16x16, и в зависимости от того, какие 4
пикселя выберутся, будут получены разные цвета. А изображение справа внизу остаётся постоянного цвета,
так как использует предпоследнее (почти самое маленькое) изображение из мипмапа.</p>
<p>Второй пример показывает полигоны, уходящие далеко вглубь экрана.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips-tri-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips-tri-linear.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>6 лент, идущих вглубь экрана, используют 6 различных моделей фильтрации,
рассмотренных выше. Верхняя левая лента использует <code>NEAREST</code> и выглядит
очень угловатой. Верхняя средняя использует <code>LINEAR</code>, и она ненамного лучше.
Правая верхняя использует <code>NEAREST_MIPMAP_NEAREST</code>. Кликните на изображении
для переключения на текстуру, где каждое изображение из мипмапа отличается
по цвету, и вам будет легко определить, какое именно изображение используется.
Нижняя левая лента использует <code>LINEAR_MIPMAP_NEAREST</code>, при котором выбирается
лучшее изображение мипмапа, а затем смешивается 4 пикселя из этого изображения.
Хороши видны переходы от одного изображения мипмапа к другому. Нижнее
изображение посередине использует <code>NEAREST_MIPMAP_LINEAR</code>, где подбираются 2
наиболее подходящих изображения из мипмапа, из каждого берётся по пикселю и
смешивается. В нём можно по-прежнему разглядеть угловатость, особенно в
горизонтальном направлении. Ну и нижнее правое изображение использует
<code>LINEAR_MIPMAP_LINEAR</code>, где подбираются 2 наиболее подходящих изображения из
мипмапа, из каждого выбирается по 4 пикселя, и эти 8 пикселей смешиваются.</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/different-colored-mips.png" /></p>
<div class="webgl_center">мипмапы с изображениями разных цветов</div>

<p>Возможно, вы сейчас думаете, зачем вообще использовать что-то отличное от
<code>LINEAR_MIPMAP_LINEAR</code>, которое, вероятно, лучше всех. Причин множество.
Во-первых, <code>LINEAR_MIPMAP_LINEAR</code> - самая медленная. Чтение 8 пикселей
происходит медленнее, чем чтение одного. На современных видеокартах скорей
всего это не будет проблемой, если вы используете одновременно одну текстуру,
но современные игры могут использовать от 2 до 4 текстур сразу. 4 текстуры
* 8 пикселей на текстуру = чтение 32 пикселей для каждой отрисовки. Это
будет медленным. Во-вторых, вам могут понадобиться определённые эффекты.
Например, если вам нужно получить пикселизованный <em>ретро</em> вид, возможно,
вы захотите использовать <code>NEAREST</code>. Кроме того, для мипмапов нужна память.
По сути, они используют на 33% больше памяти. Это может быть большим объёмом
памяти, особенно для очень больших текстур вроде приветственного экрана игры.
Если вы не планируете отрисовывать объект меньше, чем самый большой размер
изображения, зачем создавать уменьшенные копии и тратить на них память?
Вместо этого просто используйте <code>NEAREST</code> или <code>LINEAR</code>, так как они всегда
используют первое изображение.</p>
<p>Для задания фильтры вызовите <code>gl.texParameter</code> следующим образом:</p>
<pre class="prettyprint"><code>gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre><p>Настройка <code>TEXTURE_MIN_FILTER</code> задаёт поведение фильтра, когда отрисовываемый
объект меньше самого большого изображения мипмапа. Настройка <code>TEXTURE_MAG_FILTER</code>
задаёт поведение фильтра, когда отрисовываемый объект больше самого большого
изображения мипмапа. Для <code>TEXTURE_MAG_FILTER</code> допустимыми значениями являются
только <code>NEAREST</code> и <code>LINEAR</code>.</p>
<p>Скажем, мы хотим использовать следующую текстуру.</p>
<p><img class="webgl_center" src="../../resources/keyboard.jpg" /></p>
<p>Вот, что из этого выйдет:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-bad-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-bad-npot.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Почему не видно текстуру клавиатуры? Потому что у WebGL есть строгое ограничение - размер текстуры должен быть
степенью двойки в обоих измерениях. Степени двойки - 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048 и т.д.
Текстура с буквой &#39;F&#39; имеет размер 256x256. 256 - степень двойки. А размер текстуры клавиатуры - 320x240. Ни
один из этих размеров не является степенью двойки, поэтому текстура не отображается. В шейдере, в котором
вызывается <code>texture2D</code>, при некорректно настроенной текстуре используется цвет (0, 0, 0, 1) - чёрный. Если вы
откроете консоль JavaScript (консоль браузера), вы сможете увидеть ошибки касательно проблемы с текстурой.</p>
<pre class="prettyprint"><code>WebGL: INVALID_OPERATION: generateMipmap: level 0 not power of 2
   or not all the same size
WebGL: drawArrays: texture bound to texture unit 0 is not renderable.
   It maybe non-power-of-2 and have incompatible texture filtering or
   is not &#39;texture complete&#39;.
</code></pre><p>Для устранения этой ошибки нам нужно задать режим оборачивания <code>CLAMP_TO_EDGE</code>
и отключить мипмапы, используя фильтр<code>LINEAR</code> или <code>NEAREST</code>.</p>
<p>Изменим код загрузки изображения соответствующим образом. Для начала нам понадобится
функция, которая скажет, является ли значение степенью двойки.</p>
<pre class="prettyprint"><code>function isPowerOf2(value) {
  return (value &amp; (value - 1)) == 0;
}
</code></pre><p>Я не буду вдаваться в двоичную арифметику, чтобы объяснить, как это работает.
Это просто работает, мы же можем использовать функцию следующим образом:</p>
<pre class="prettyprint"><code>// асинхронная загрузка изображения
var image = new Image();
image.src = &quot;resources/keyboard.jpg&quot;;
image.addEventListener(&#39;load&#39;, function() {
  // теперь, когда изображение загрузилось, копируем его в текстуру
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);

*  // проверяем, что размер изображения равен степени двойки в обоих измерениях
*  if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
*     // Да, степень двойки. Генерируем мипмап.
     gl.generateMipmap(gl.TEXTURE_2D);
*  } else {
*     // Нет, это не степень двойки. Отключаем мипмапы и устанавливаем режим CLAMP_TO_EDGE
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
*  }
}
</code></pre><p>И вот результат.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-good-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-good-npot.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Распространённый вопрос - &quot;Как мне применить разные изображения к каждой
грани куба?&quot;. Скажем, что у нас есть 6 изображений.</p>
<div class="webgl_table_div_center">
<table class="webgl_table_center">
<tr><td><img src="../resources/noodles-01.jpg" /></td><td><img src="../resources/noodles-02.jpg" /></td><td><img src="../resources/noodles-03.jpg" /></td></tr>
<tr><td><img src="../resources/noodles-04.jpg" /></td><td><img src="../resources/noodles-05.jpg" /></td><td><img src="../resources/noodles-06.jpg" /></td></tr>
</table>
</div>

<p>На ум приходят 3 варианта.</p>
<p>1) Сделать сложный шейдер, который содержит ссылки на 6 текстур и по переданной в вершину информации
шейдер понимает, какую текстуру использовать. НЕ ДЕЛАЙТЕ ТАК! Немного подумав, становится понятно,
что в итоге вами придётся написать кучу различных шейдеров, чтобы сделать то же самое для других
объектов с большим количеством граней.</p>
<p>2) Использовать 6 отдельных плоскостей вместо куба. Довольно распространённое решение. Оно не так плохо,
но работает только с достаточно простыми объектами вроде куба. Если у вас есть сфера с 1000 квадрантами
и вы захотите задать для каждого квадранта отдельную текстуру, вам придётся отрисовывать 1000 плоскостей,
что будет достаточно медленно.</p>
<p>3) И, пожалуй, <em>лучшим решением</em> будет объединение всех изображений в одну текстуру и использование
текстурных координат для сопоставления различных частей текстуры отдельным граням куба. Эта техника
используется большинством высокопроизводительных приложений (читай <em>играми</em>). Поэтому мы помещаем
все изображения в одну текстуру следующим образом:</p>
<p><img class="webgl_center" src="../../resources/noodles.jpg" /></p>
<p>и затем используем другой набор текстурных координат для каждой грани куба.</p>
<pre class="prettyprint"><code>    // выбираем нижнее левое изображение
    0   , 0  ,
    0   , 0.5,
    0.25, 0  ,
    0   , 0.5,
    0.25, 0.5,
    0.25, 0  ,
    // выбираем нижнее среднее изображение
    0.25, 0  ,
    0.5 , 0  ,
    0.25, 0.5,
    0.25, 0.5,
    0.5 , 0  ,
    0.5 , 0.5,
    // выбираем нижнее правое изображение
    0.5 , 0  ,
    0.5 , 0.5,
    0.75, 0  ,
    0.5 , 0.5,
    0.75, 0.5,
    0.75, 0  ,
    // выбираем верхнее левое изображение
    0   , 0.5,
    0.25, 0.5,
    0   , 1  ,
    0   , 1  ,
    0.25, 0.5,
    0.25, 1  ,
    // выбираем верхнее среднее изображение
    0.25, 0.5,
    0.25, 1  ,
    0.5 , 0.5,
    0.25, 1  ,
    0.5 , 1  ,
    0.5 , 0.5,
    // выбираем верхнее правое изображение
    0.5 , 0.5,
    0.75, 0.5,
    0.5 , 1  ,
    0.5 , 1  ,
    0.75, 0.5,
    0.75, 1  ,
</code></pre><p>И мы получим:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-atlas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-atlas.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Объединение нескольких изображений в одной текстуре часто называют
<em>текстурным атласом</em>. Его использование является предпочтительным, так как
грузится всего 1 текстура, и шейдер остаётся простым, так как он содержит
всего одну ссылку на текстуру и требует одного вызова для отрисовки объекта,
в то время как разбитый на плоскости объект требует одного вызова отрисовки
на каждую из текстур.</p>
<p>Есть ещё несколько вещей, которые, возможно, вы бы хотели знать о текстурах. Одна
из них - <a href="webgl-2-textures.html">использование 2 и более текстур одновременно</a>.
Вторая - <a href="webgl-cors-permission.html">загрузка изображений с других доменов</a>.
И ещё одна - <a href="webgl-3d-perspective-correct-texturemapping.html">коррекция перспективы текстуры</a>,
которая хотя и тривиальная в некотором роде, но всё же о ней полезно знать.</p>
<p>Далее разберём, <a href="webgl-data-textures.html">как передать данные в текстуру из JavaScript</a>.
Или попробуем <a href="webgl-less-code-more-fun.html">упростить код за счёт функций-помощников</a>.</p>
<div class="webgl_bottombar">
<h3>UV или Текстурные координаты?</h3>
<p>Текстурные координаты часто упрощают до UV (произносится как Ю-Ви). Я понятия
не имею, откуда взялся термин UV, разве что как положения вершин используют
<code>x, y, z, w</code>, так и текстурные координаты используют <code>s, t, u, v</code>,
чтобы было понятней, о каких из двух типов координат говорится. На основании
этого можно подумать, что они бы назывались ST, особенно учитывая, что настройки
оборачивания текстуры называются <code>TEXTURE_WRAP_S</code> и <code>TEXTURE_WRAP_T</code>,
но по каким-то причинам люди назвали их UV.</p>
<p>Теперь вы знаете, что если кто-то говорит о UV, он имеет ввиду текстурные координаты.</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 3D - Текстуры';
            var disqus_title = 'WebGL 3D - Текстуры';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



