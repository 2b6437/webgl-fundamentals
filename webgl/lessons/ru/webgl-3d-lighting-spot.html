<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-3d-lighting-spot.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 3D - Прожектор" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />
<meta property="og:description" content="Создание света от прожектора в WebGL" />
<meta property="og:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-3d-lighting-spot.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webglfundamentals.org" />
<meta name="twitter:title" content="WebGL 3D - Прожектор" />
<meta name="twitter:url" content="http://webglfundamentals.org/webgl/lessons/ru/webgl-3d-lighting-spot.html" />
<meta name="twitter:description" content="Создание света от прожектора в WebGL" />
<meta name="twitter:image:src" content="http://webglfundamentals.org/webgl/lessons/resources/webglfundamentals.jpg" />


<title>WebGL 3D - Прожектор</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-spot.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-lighting-spot.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-spot.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-spot.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-lighting-spot.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-spot.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-lighting-spot.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html" >简体中文</a>
</select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGLFundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 3D - Прожектор</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья продолжает <a href="webgl-3d-lighting-point.html">точечное освещение в WebGL</a>.
Если вы ещё не читали её, советую <a href="webgl-3d-lighting-point.html">начать с неё</a>.</p>
<p>В последней статье мы рассмотрели точечное освещение, где для каждой
точки поверхности объекта рассчитывалось направление от источника света
до данной точки поверхности. Дальнейший расчёт был таким же, как и в
<a href="webgl-3d-lighting-directional.html">направленном освещении</a>, а именно
находилось скалярное произведение нормали поверхности (т.е. направления
поверхности) и направления освещения. В результате получалось значение
1, если направления совпадали и освещение было максимальным, значение 0,
если два направления были перпендикулярными, и, наконец, значение -1
было в том случае, когда вектора были направлены в разные стороны. Данное
значение мы использовали как множитель цвета поверхности, что в результате
давало нам освещение.</p>
<p>В освещении прожектора совсем небольшое отличие. На самом деле, учитывая
ваши накопленные знания, при желании вы сможете придумать свою реализацию
данного освещения.</p>
<p>Представьте точку света, от которой свет идёт во все стороны. Для создания
прожектора нам необходимо лишь выбрать направление от точки освещения -
это будет направление прожектора. Затем для каждого луча мы могли бы
получить скалярное произведение между направлением луча и выбранным
направлением прожектора. Полученное значение мы можем сравнить с некоторой
выбранной величиной, которая отрезает свет. Если мы вышли за пределы этой
величины - освещения нет.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example noborder" style="width: 500px; height: 400px;" src="/webgl/lessons/resources/spot-lighting.html"></iframe>
</div>

</p>
<p>В диаграмме выше вы можете видеть свет вместе с лучами, идущими во всех
направлениях, а также значение скалярного произведения для каждого луча.
Также у нас есть определённое <strong>направление</strong> освещения (direction) и
предел освещения (limit). Для данного предела освещения мы находим его косинус.
Если скалярное произведение нашего выбранного направления освещения и отдельного луча
выше значения косинуса предела, то данный луч участвует в освещении. В другом случае
луч ничего не освещает.</p>
<p>Объясню по-другому. Скажем, наш предел равен 20 градусам. Мы можем преобразовать
значение в радианы, а затем в диапазон от -1 до 1 через косинус. Назовём это скалярным
пространством. Вот небольшая таблица для некоторых значений пределов:</p>
<pre class="prettyprint"><code>          пределы в
 градусах| радианах| скалярном пространстве
 --------+---------+----------
    0    |   0.0   |    1.0
    22   |    .38  |     .93
    45   |    .79  |     .71
    67   |   1.17  |     .39
    90   |   1.57  |    0.0
   180   |   3.14  |   -1.0
</code></pre><p>Далее мы просто сравниваем с полученным пределом:</p>
<pre class="prettyprint"><code>dotFromDirection = dot(surfaceToLight, -lightDirection)
if (dotFromDirection &gt;= limitInDotSpace) {
   // освещение есть
}
</code></pre><p>Теперь можно перейти к реализации.</p>
<p>Сначала изменим фрагментный шейдер из
<a href="webgl-3d-lighting-point.html">последней статьи</a>.</p>
<pre class="prettyprint"><code>precision mediump float;

// Передаётся из вершинного шейдера
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_color;
uniform float u_shininess;
+uniform vec3 u_lightDirection;
+uniform float u_limit;          // в скалярном пространстве

void main() {
  // v_normal - это varying-переменная, которая интерполируется
  // и поэтому не будет единичным вектором. Нормализуем
  // переменную и получаем единичный вектор.
  vec3 normal = normalize(v_normal);

  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

-  float light = dot(normal, surfaceToLightDirection);
+  float light = 0.0;
  float specular = 0.0;

+  float dotFromDirection = dot(surfaceToLightDirection,
+                               -u_lightDirection);
+  if (dotFromDirection &gt;= u_limit) {
*    light = dot(normal, surfaceToLightDirection);
*    if (light &gt; 0.0) {
*      specular = pow(dot(normal, halfVector), u_shininess);
*    }
+  }

  gl_FragColor = u_color;

  // Умножаем только значение цвета (без прозрачности)
  // на значение света
  gl_FragColor.rgb *= light;

  // Просто добавляем блики
  gl_FragColor.rgb += specular;
}
</code></pre><p>Само собой нам необходимо получить ссылки на uniform-переменные,
которые мы только что добавили</p>
<pre class="prettyprint"><code>  var lightDirection = [?, ?, ?];
  var limit = degToRad(20);

  ...

  var lightDirectionLocation = gl.getUniformLocation(program, &quot;u_lightDirection&quot;);
  var limitLocation = gl.getUniformLocation(program, &quot;u_limit&quot;);
</code></pre><p>и установить им значения</p>
<pre class="prettyprint"><code>    gl.uniform3fv(lightDirectionLocation, lightDirection);
    gl.uniform1f(limitLocation, Math.cos(limit));
</code></pre><p>Получаем такой результат:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-spot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-spot.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Обращу внимание на несколько моментов. Во-первых, мы инвертируем
<code>u_lightDirection</code>, чтобы оба вектора были направлены в одну
сторону при их совпадении. Это означает, что нам нужно сравнить
surfaceToLightDirection с инвертированным направлением прожектора.
Это не единственный способ. Мы могли бы, например, передать обратное
направление при установке uniform-переменной. Этот способ был бы
на первом месте в моём личном хит-параде, но я подумал, что
uniform-переменная с именем <code>u_lightDirection</code> будет более понятной
по сравнению с <code>u_reverseLightDirection</code> и <code>u_negativeLightDirection</code>.</p>
<p>Во-вторых, по возможности я стараюсь избегать условий в шейдерах, хотя,
возможно, это только моё предпочтение. Думаю, причиной тому отчасти
является тот факт, что раньше в шейдерах не было условий. Если вы добавляли
условие, компилятор шейдеров расширял код, добавляя повсюду множество
умножений на 0 и 1, чтобы в итоге обойтись без условий. То есть добавление
условий в прошлом вело за собой сильное расширение кода. Не знаю, осталось
ли так по сей день, но в любом случае давайте избавимся от условий - хотя
бы для того, чтобы показать возможные варианты. А вы уже сами сможете решить,
использовать их или нет.</p>
<p>У нас есть функция на GLSL под названием <code>step</code>. Она принимает 2 значения, и
если второе значение больше или равно первому значению, функция возвращает 1.0,
в противном случае возвращается 0. В JavaScript она бы выглядела примерно так:</p>
<pre class="prettyprint"><code>function step(a, b) {
   if (b &gt;= a) {
       return 1;
   } else {
       return 0;
   }
}
</code></pre><p>Давайте переделаем функцию <code>step</code> и избавимся от условий.</p>
<pre class="prettyprint"><code>  float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
  // inLight примет значение 1, когда мы внутри прожектора, и значение 0 за его пределами
  float inLight = step(u_limit, dotFromDirection);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);
</code></pre><p>Как видите, визуально ничего не изменилось:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-spot-using-step.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-spot-using-step.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вот только луч от прожектора у нас получился очень уж резкий. Внутри
кольца у нас светлое пятно, а за границей света сразу идёт чернота.</p>
<p>Для исправления ситуации мы могли бы использовать два предела вместо
одного - внутренний и внешний предел. В границах внутреннего предела
мы будем использовать значение 1.0, за рамками внешнего предела будет
значение 0.0. А между пределами значение будет плавно затухать от
единицы до нуля.</p>
<p>Следующий код вполне справится с данной задачей</p>
<pre class="prettyprint"><code>-uniform float u_limit;          // в скалярном пространстве
+uniform float u_innerLimit;     // в скалярном пространстве
+uniform float u_outerLimit;     // в скалярном пространстве

...

  float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
-  float inLight = step(u_limit, dotFromDirection);
+  float limitRange = u_innerLimit - u_outerLimit;
+  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);
</code></pre><p>И да, это сработало как нужно</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-spot-falloff.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-spot-falloff.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Теперь мы получили то, что действительно похоже на свет прожектора!</p>
<p>Следует помнить, что в случае, когда значение <code>u_innerLimit</code> равно
<code>u_outerLimit</code>, значение <code>limitRange</code> будет равно нулю. Тогда при делении
на <code>limitRange</code> мы получим деление на ноль. В шейдере делать ничего не нужно,
просто нужно контролировать в JavaScript, что <code>u_innerLimit</code> никогда не
будет равен <code>u_outerLimit</code> (в нашем примере это не реализовано).</p>
<p>В GLSL есть функция, которая позволит ещё немного упростить наш код.
Она называется <code>smoothstep</code>. Как и <code>step</code>, она возвращает значение от 0
до 1, но принимает как нижнюю, так и верхнюю границу, и плавно переходит
между этими значениями.</p>
<pre class="prettyprint"><code> smoothstep(lowerBound, upperBound, value)
</code></pre><p>Применим эту функцию</p>
<pre class="prettyprint"><code>  float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
-  float limitRange = u_innerLimit - u_outerLimit;
-  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
  float inLight = smoothstep(u_outerLimit, u_innerLimit, dotFromDirection);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);
</code></pre><p>Как видим, всё отлично работает</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-lighting-spot-falloff-using-smoothstep.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-lighting-spot-falloff-using-smoothstep.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Разница в том, что функция <code>smoothstep</code> использует эрмитову интерполяцию
вместо линейной интерполяции. Это значит, что между <code>lowerBound</code> и <code>upperBound</code>
значение будет интерполироваться, как показано на картинке справа, а изменение
значения линейной интерполяции отображено слева.</p>
<p><img class="webgl_center invertdark" src="../resources/linear-vs-hermite.png" /></p>
<p>Насколько между ними большая разница - решайте сами.</p>
<p>Ещё один подводный камень состоит в том, что функция <code>smoothstep</code> вернёт
неопределённый результат при значении <code>lowerBound</code> большем или равном
значению <code>upperBound</code>. Немного выше мы уже сталкивались с проблемой, когда
оба значения равны. А случай, когда значение <code>lowerBound</code> становится больше
значения <code>upperBound</code>, является новой проблемой, и вам необходимо
контролировать, чтобы она не возникала при расчёте освещения прожектора.</p>
<div class="webgl_bottombar">
<h3>Будьте осторожны с неопределённым поведением в GLSL</h3>
<p>
Несколько функций в GLSL не определены на отдельных значениях.
Попытка возвести негативное число в степень через функцию <code>pow</code>
является одним из примеров, так как мы получим мнимое число. Мы
встретили и другой пример с функцией <code>smoothstep</code>.</p>
<p>
Постарайтесь запоминать подобные функции, иначе результаты ваших
шейдеров будут отличаться на различных компьютерах. <a href="https://www.khronos.org/files/opengles_shading_language.pdf">
В восьмой секции спецификации</a> перечислены все встроенные функции,
описано их назначение и есть ли у них неопределённое поведение.</p>
<p>Приведу список функций с неопределённым поведением. Под <code>genType</code>
здесь стоит понимать <code>float</code>, <code>vec2</code>, <code>vec3</code> и <code>vec4</code>.</p>

<pre class="prettyprint"><code>genType asin (genType x)</code></pre><p>Арксинус. Возвращает угол, чей синус равен x.
Возвращаемое значение находится в диапазоне [−π/2, π/2]. Результат не определён при ∣x∣ > 1.</p>

<pre class="prettyprint"><code>genType acos (genType x)</code></pre><p>Арккосинус. Возвращает угол, чей косинус равен x.
Возвращаемое значение находится в диапазоне [0, π]. Результат не определён при ∣x∣ > 1.</p>

<pre class="prettyprint"><code>genType atan (genType y, genType x)</code></pre><p>Арктангенс. Возвращает угол, чей тангенс равен y/x.
Знаки перед x и y означают, в какую четверть попадёт угол. Возвращаемое значение находится в диапазоне [−π,π].
Результат не определён, когда x и y равны 0.</p>

<pre class="prettyprint"><code>genType pow (genType x, genType y)</code></pre><p>Возвращает x в степени y, т.е. x<sup>y</sup>.
Результат не определён при x < 0. Результат не определён при x = 0 и y <= 0.</p>

<pre class="prettyprint"><code>genType log (genType x)</code></pre><p>Возвращает натуральный логарифм x, т.е. значение,
которое удовлетворяет условию x = e<sup>y</sup>.
Результат не определён при x <= 0.</p>

<pre class="prettyprint"><code>genType log2 (genType x)</code></pre><p>Возвращает двоичный логарифм от x, т.е. значение,
которое удовлетворяет условию x=2<sup>y</sup>.
Результат не определён при x <= 0.</p>

<pre class="prettyprint"><code>genType sqrt (genType x)</code></pre><p>Возвращает √x .
Результат не определён при x < 0.</p>

<pre class="prettyprint"><code>genType inversesqrt (genType x)</code></pre><p>
Возвращает 1/√x.
Результат не определён при x <= 0.</p>

<pre class="prettyprint"><code>genType clamp (genType x, genType minVal, genType maxVal)
genType clamp (genType x, float minVal, float maxVal)</code></pre><p>
Возвращает (max (x, minVal), maxVal).
Результат не определён при minVal > maxVal</p>

<pre class="prettyprint"><code>genType smoothstep (genType edge0, genType edge1, genType x)
genType smoothstep (float edge0, float edge1, genType x)</code></pre><p>
Возвращает 0.0 при x <= edge0 и 1.0 при x >= edge1, а также выполняет
гладкую эрмитову интерполяцию между 0 и 1 при edge0 < x < edge1. Функция
полезна, когда вам нужна ограничивающая функция с плавным переходом.
Эквивалент можно представить так:
</p>
<pre class="prettyprint">
 genType t;
 t = clamp ((x – edge0) / (edge1 – edge0), 0, 1);
 return t * t * (3 – 2 * t);
</pre>
<p>Результат не определён при edge0 >= edge1.</p>

</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-lighting-spot.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-lighting-spot.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-lighting-spot.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-lighting-spot.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-lighting-spot.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-lighting-spot.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-lighting-spot.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как работает WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL в WebGL</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продолжаем обработку изображений в WebGL</a></li>
        </ul>
  <li>Математика переноса, поворота и масштабирования в 2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D-перенос в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D-поворот в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D-масштабирование в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D-матрицы в WebGL</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">WebGL 3D - Ортогональ</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">WebGL 3D - Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">WebGL 3D - Камеры</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">WebGL 3D - Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">WebGL 3D - Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">WebGL 3D - Прожектор</a></li>
        </ul>
  <li>Структура и устройство</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">WebGL - Меньше кода, больше веселья</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">WebGL - Отрисовка нескольких объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">WebGL - Графы сцены</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">WebGL 3D - Создание модели</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">WebGL 3D - Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">WebGL - Данные для текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">WebGL - Использование 2 и более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">WebGL - Кросс-доменные изображения</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">WebGL 3D - Перспективная коррекция текстур</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">WebGL - Рендеринг в текстуру</a></li>
        </ul>
  <li>Приёмы</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">WebGL 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">WebGL 2D - Стек матриц</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">WebGL текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">WebGL текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">WebGL текст - Используем текстуру</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">WebGL текст - Используем глиф-текстуру</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">WebGL Установка и настройка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Шаблон WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas в WebGL</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">WebGL - Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL и прозрачность</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">WebGL - 2D и 3D библиотеки</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">WebGL - Антипаттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Документация по вспомогательным функциям</a></li>
  <li><a href="http://twgljs.org">TWGL, лёгкая библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/webgl">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/webgl-fundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 3D - Прожектор';
            var disqus_title = 'WebGL 3D - Прожектор';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



