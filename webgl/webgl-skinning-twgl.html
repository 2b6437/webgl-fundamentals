<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>WebGL - Skinning</title>
<link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" />
</head>
<body>
<canvas id="canvas"></canvas>
</body>
<!-- vertex shader -->
<script id="vs" type="notjs">
attribute vec4 position;
attribute vec4 weight;
attribute vec4 boneNdx;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 bones[4];

void main() {

  gl_Position = projection * view *
                (bones[int(boneNdx[0])] * position * weight[0] +
                 bones[int(boneNdx[1])] * position * weight[1] +
                 bones[int(boneNdx[2])] * position * weight[2] +
                 bones[int(boneNdx[3])] * position * weight[3]);

}
</script>
<script id="fs" type="notjs">
precision mediump float;
uniform vec4 color;
void main () {
  gl_FragColor = color;
}
</script>
<script id="vs2" type="notjs">
attribute vec4 position;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

void main() {
  gl_Position = projection * view * model * position;
}
</script>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="resources/webgl-utils.js"></script>
<script src="resources/webgl-lessons-ui.js"></script>
<script src="resources/twgl-full.min.js"></script>
<script>
"use strict";

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  var canvas = document.getElementById("canvas");
  var gl = canvas.getContext("webgl");
  if (!gl) {
    return;
  }

  var m4 = twgl.m4;

  // compiles and links the shaders, looks up attribute and uniform locations
  var programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

  var arrays = {
    position: {
      size: 2,
      data: [
       0,  1,  // 0
       0, -1,  // 1
       2,  1,  // 2
       2, -1,  // 3
       4,  1,  // 4
       4, -1,  // 5
       6,  1,  // 6
       6, -1,  // 7
       8,  1,  // 8
       8, -1,  // 9
      ],
    },
    boneNdx: {
      size: 4,
      data: [
        0, 0, 0, 0,  // 0
        0, 0, 0, 0,  // 1
        0, 1, 0, 0,  // 2
        0, 1, 0, 0,  // 3
        1, 0, 0, 0,  // 4
        1, 0, 0, 0,  // 5
        1, 2, 0, 0,  // 6
        1, 2, 0, 0,  // 7
        2, 0, 0, 0,  // 8
        2, 0, 0, 0,  // 9
      ],
    },
    weight: {
      size: 4,
      data: [
       1, 0, 0, 0,  // 0
       1, 0, 0, 0,  // 1
      .5,.5, 0, 0,  // 2
      .5,.5, 0, 0,  // 3
       1, 0, 0, 0,  // 4
       1, 0, 0, 0,  // 5
      .5,.5, 0, 0,  // 6
      .5,.5, 0, 0,  // 7
       1, 0, 0, 0,  // 8
       1, 0, 0, 0,  // 9
      ],
    },

    indices: [
      0, 1,
      0, 2,
      1, 3, //
      2, 3,
      2, 4,
      3, 5, //
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ]
  };
  // calls gl.createBuffer, gl.bindBuffer, gl.bufferData
  var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

  var boneArray = new Float32Array(4 * 16);

  var uniforms = {
    projection: m4.ortho(-20, 20, -10, 10, -1, 1),
    view: m4.translation([-6, 0, 0]),
    bones: boneArray,
    color: [1, 0, 0, 1],
  };

  // make views for each bone. This lets all the bones
  // exist in 1 array for uploading but as separate
  // arrays for using with the math functions
  var boneUniforms = [];  // the uniform data
  var bones = [];         // the value before multiplying by inverse bind matrix
  var bindPose = [];      // the bind matrix
  for (var i = 0; i < 4; ++i) {
    boneUniforms.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
    bindPose.push(m4.identity());  // just allocate storage
    bones.push(m4.identity());     // just allocate storage
  }

   // rotate each bone by a and simulate a hierarchy
   function computeBoneMatrices(bones, a) {
    var m = m4.identity();
    m4.rotateZ(m, a, bones[0]);
    m4.translate(bones[0], [4, 0, 0], m);
    m4.rotateZ(m, a, bones[1]);
    m4.translate(bones[1], [4, 0, 0], m);
    m4.rotateZ(m, a, bones[2]);
    // bones[3] is not used
  }

  // compute the initial positions of each matrix
  computeBoneMatrices(bindPose, 0);

  // compute their inverses
  var bindPoseInv = bindPose.map(function(m) {
    return m4.inverse(m);
  });

  function render(time) {
    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    var t = time * 0.001;
    var a = Math.sin(t) * 0.8;
    computeBoneMatrices(bones, a);

    // multiply each by its bindPoseInverse
    bones.forEach(function(bone, ndx) {
      m4.multiply(bone, bindPoseInv[ndx], boneUniforms[ndx]);
    });

    gl.useProgram(programInfo.program);
    // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);

    // calls gl.uniformXXX, gl.activeTexture, gl.bindTexture
    twgl.setUniforms(programInfo, uniforms);

    // calls gl.drawArrays or gl.drawIndices
    twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);

    drawAxis(uniforms.projection, uniforms.view, bones);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);


  // --- ignore below this line - it's not relevant to the answer and it's a bad example ---

  var axisProgramInfo;
  var axisBufferInfo;
  function drawAxis(projection, view, bones) {
    if (!axisProgramInfo) {
      axisProgramInfo = twgl.createProgramInfo(gl, ['vs2', 'fs']);
      axisBufferInfo  = twgl.createBufferInfoFromArrays(gl, {
        position: {
          size: 2,
          data: [
            0, 0,
            1, 0,
          ],
        },
      });
    }

    var uniforms = {
      projection: projection,
      view: view,
    };

    gl.useProgram(axisProgramInfo.program);
    twgl.setBuffersAndAttributes(gl, axisProgramInfo, axisBufferInfo);

    for (var i = 0; i < 3; ++i) {
      drawLine(bones[i], 0, [0 ,1, 0, 1]);
      drawLine(bones[i], Math.PI * 0.5, [0, 0, 1, 1]);
    }

    function drawLine(mat, angle, color) {
      uniforms.model = m4.rotateZ(mat, angle);
      uniforms.color = color;
      twgl.setUniforms(axisProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, axisBufferInfo, gl.LINES);
    }
  }
}

main();
</script>
</html>
