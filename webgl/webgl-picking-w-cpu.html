<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>WebGL - Picking - CPU</title>
<link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" />
</head>
<body>
<div class="description">
CPU Picking
</div>
<canvas id="canvas"></canvas>
<div id="info"></div>
</body>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="resources/webgl-utils.js"></script>
<script src="resources/m4.js"></script>
<script src="resources/primitives.js"></script>
<script src="resources/chroma.min.js"></script>
<!-- vertex shader -->
<script id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
<!-- fragment shader -->
<script id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

uniform vec4 u_colorMult;

void main() {
   gl_FragColor = v_color * u_colorMult;
}
</script>
<script>
"use strict";

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.getElementById("canvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    return;
  }

  // creates buffers with position, normal, texcoord, and vertex color
  // data for primitives by calling gl.createBuffer, gl.bindBuffer,
  // and gl.bufferData
  const sphereBufferInfo = primitives.createSphereWithVertexColorsBufferInfo(gl, 10, 12, 6);
  const cubeBufferInfo   = primitives.createCubeWithVertexColorsBufferInfo(gl, 20);
  const coneBufferInfo   = primitives.createTruncatedConeWithVertexColorsBufferInfo(gl, 10, 0, 20, 12, 1, true, false);

  const shapes = [
    { bufferInfo: sphereBufferInfo, radiusSq: 10 * 10, },
    { bufferInfo: cubeBufferInfo,   radiusSq: 10 * 10, },
    { bufferInfo: coneBufferInfo,   radiusSq: 10 * 10, },
  ];


  // setup GLSL programs
  const programInfo = webglUtils.createProgramInfo(
      gl, ["3d-vertex-shader", "3d-fragment-shader"]);

  function degToRad(d) {
    return d * Math.PI / 180;
  }

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function eMod(x, n) {
    return x >= 0 ? (x % n) : ((n - (-x % n)) % n);
  }


  const fieldOfViewRadians = degToRad(60);

  const objectsToDraw = [];
  const objects = [];

  // Make infos for each object for each object.
  const baseHue = rand(0, 360);
  const numObjects = 200;
  for (let ii = 0; ii < numObjects; ++ii) {
    const id = ii + 1;
    const {radiusSq, bufferInfo} = shapes[ii % shapes.length];
    const object = {
      uniforms: {
        u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
        u_matrix: m4.identity(),
        u_id: [
          ((id >>  0) & 0xFF) / 0xFF,
          ((id >>  8) & 0xFF) / 0xFF,
          ((id >> 16) & 0xFF) / 0xFF,
          ((id >> 24) & 0xFF) / 0xFF,
        ],
      },
      translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
      xRotationSpeed: rand(0.8, 1.2),
      yRotationSpeed: rand(0.8, 1.2),
      radiusSq,
    };
    objects.push(object);
    objectsToDraw.push({
      programInfo: programInfo,
      bufferInfo,
      uniforms: object.uniforms,
    });
  }

  function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
    let matrix = m4.translate(viewProjectionMatrix,
        translation[0],
        translation[1],
        translation[2]);
    matrix = m4.xRotate(matrix, xRotation);
    return m4.yRotate(matrix, yRotation);
  }

  requestAnimationFrame(drawScene);

  function drawObjects(objectsToDraw, overrideProgramInfo) {
    objectsToDraw.forEach(function(object) {
      const programInfo = overrideProgramInfo || object.programInfo;
      const bufferInfo = object.bufferInfo;

      gl.useProgram(programInfo.program);

      // Setup all the needed attributes.
      webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

      // Set the uniforms.
      webglUtils.setUniforms(programInfo, object.uniforms);

      // Draw
      gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
    });
  }

/*
module.exports = intersectRaySphere
function intersectRaySphere (out, origin, direction, center, radius) {
  sub(tmp, center, origin)
  var len = dot(direction, tmp)
  if (len < 0) { // sphere is behind ray
    return null
  }

  scaleAndAdd(tmp, origin, direction, len)
  var dSq = squaredDist(center, tmp)
  var rSq = radius * radius
  if (dSq > rSq) {
    return null
  }

  scale(out, direction, len - Math.sqrt(rSq - dSq))
  return add(out, out, origin)
}
*/
/*

  function intersectRaySphere(start, end, center, radiusSq) {
    const direction = m4.subtractVectors(end, start);
    const tmp = m4.subtractVectors(center, start);
    const len = m4.dot(direction, tmp);
    if (len < 0) {
      return;
    }
    const distSq = m4.distanceSq(center, end);
    if (distSq > radiusSq) {
      return;
    }

    const temp = m4.scaleVector(direction, len - Math.sqrt(radiusSq - distSq));
    return m4.addVectors(temp, origin);
  }
*/
/*
  function intersectRaySphere(origin, ray, center, radius) {
    var offset = v3.subtract(origin, center);
    var a = v3.lengthSq(ray);
    var b = 2 * v3.dot(ray, offset);
    var c = v3.lengthSq(offset) - radius * radius;
    var discriminant = b * b - 4 * a * c;

    if (discriminant > 0) {
      var t = (-b - Math.sqrt(discriminant)) / (2 * a);
      var hit = v3.add(origin, v3.mulScalar(ray, t));
      return hit; //new HitTest(t, hit, hit.subtract(center).divide(radius));
    }
  }
*/
  function intersectRaySphere(start, end, center, radiusSq) {
    const offset = m4.subtractVectors(start, center);
    const ray = m4.subtractVectors(end, start);
    const a = m4.lengthSq(ray);
    const b = 2 * m4.dot(ray, offset);
    const c = m4.lengthSq(offset) - radiusSq;
    const discriminant = b * b - 4 * a * c;

    if (discriminant > 0) {
      const t = (-b - Math.sqrt(discriminant)) / (2 * a);
      const hit = m4.addVectors(origin, m4.scaleVector(ray, t));
      return hit;
    }
  }

  // mouseX and mouseY are in CSS display space relative to canvas
  let mouseX = -1;
  let mouseY = -1;
  let oldPick;
  let oldPickColor;
  let frameCount = 0;

  // Draw the scene.
  function drawScene(time) {
    time *= 0.0005;
    ++frameCount;

    webglUtils.resizeCanvasToDisplaySize(gl.canvas);

    // Compute the projection matrix
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const projectionMatrix =
        m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

    // Compute the camera's matrix using look at.
    const cameraPosition = [0, 0, 100];
    const target = [0, 0, 0];
    const up = [0, 1, 0];
    const cameraMatrix = m4.lookAt(cameraPosition, target, up);

    // Make a view matrix from the camera matrix.
    const viewMatrix = m4.inverse(cameraMatrix);

    const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

    // Compute the matrices for each object.
    objects.forEach(function(object) {
      object.uniforms.u_matrix = computeMatrix(
          viewProjectionMatrix,
          object.translation,
          object.xRotationSpeed * time,
          object.yRotationSpeed * time);
    });

    // ------ Figure out what objects/triangles are under the mouse
    const clipX = mouseX / gl.canvas.clientWidth  *  2 - 1;
    const clipY = mouseY / gl.canvas.clientHeight * -2 + 1;

    const intersections = [];
    objects.forEach(function(object) {
      const invMat = m4.inverse(object.uniforms.u_matrix);
      const start = m4.transformPoint(invMat, [clipX, clipY, -1]);
      const end   = m4.transformPoint(invMat, [clipX, clipY,  1]);
      const hit = intersectRaySphere(start, end, [0, 0, 0], object.radiusSq);
      if (hit) {
        intersections.push({object, hit});
      }
    });

    // restore the object's color
    if (oldPick) {
      oldPick.uniforms.u_colorMult = oldPickColor;
      oldPick = undefined;
    }

    // highlight object under mouse
    if (intersections.length > 0) {
      oldPick = intersections[0].object;
      oldPickColor = oldPick.uniforms.u_colorMult;
      oldPick.uniforms.u_colorMult = (frameCount & 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
    }

    // ------ Draw the objects to the canvas

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);

    drawObjects(objectsToDraw);

    requestAnimationFrame(drawScene);
  }

  gl.canvas.addEventListener('mousemove', (e) => {
     const rect = canvas.getBoundingClientRect();
     mouseX = e.clientX - rect.left;
     mouseY = e.clientY - rect.top;
  });
}

main();
</script>
</html>


